var unstruct = require('./unstruct');
var scanner2 = require("./scanner2");
var { createString } = require("./common");
function test(codetext, expect, ret = false) {
    var code = scanner2(codetext);
    var i = -2;
    code = unstruct(code, () => ++i >= 0 ? "_" + i : '_', ret);
    assert(code.map(createString).join("; "), expect);
}

test('a+b', "a + b");
test('a + !c', "_ = !c, a + _");
test('a + b * c', "_ = b * c, a + _");
test('a + b * !c', "_ = !c, _ = b * _, a + _");
test('a + b * c ** !d', '_ = !d, _ = c ** _, _ = b * _, a + _');
test('a * a + b * c', "_ = a * a, _0 = b * c, _ + _0");
test('a * a + b * c * c ** d', "_ = a * a, _0 = b * c, _1 = c ** d, _0 = _0 * _1, _ + _0");
test('a * a || b * c * c ** d', "_ = a * a @re _ = b * c, _0 = c ** d, _ * _0");
test('a * a || b * c || c * d', "_ = a * a @re _ = b * c @re c * d");
test('a?b:c', "_ = a; return [_ ? 1 : 2, _]; _ = b; return [2, _]; _ = c; return [1, _]");
test('a * a && b * c * c ** d', "_ = a * a @rz _ = b * c, _0 = c ** d, _ * _0");
test('a = b', "a = b; return [1, a]", true);
test('a = b = c', "_ = c; b = _; a = _; return [1, a]", true);
test('a = b = c + d', "_ = c + d; b = _; a = _; return [1, a]", true);
test('a = b = c + d * 1', "_ = d * 1; _ = c + _; b = _; a = _; return [1, a]", true);
test('return a = b', "a = b; return [1, a]", true);
test('a*a', "_ = a * a; return [1, _]", true);
test('a * a && b * c * c ** d', "_ = a * a; if (!_) return [2, _]; _ = b * c; _0 = c ** d; _ = _ * _0; return [1, _]", true);

test("await a", "_ = a; return [1, _]", true);
test("await a()", "_ = a(); return [1, _]", true);
test("(1+ +1)", "_ = +1; _ = 1 + _; _ = (_); return [1, _]", true);
test("await a(await b)", "_ = b; return [1, _]; _ = a(_); return [1, _]", true);
test("await a(await b).s(await c)", "_ = b; return [1, _]; _ = a(_); _0 = c; return [1, _0]; _ = _.s(_0); return [1, _]", true);
test("a*a + await a(await b).s(await c)", "_ = a * a; _0 = b; return [1, _0]; _0 = a(_0); _1 = c; return [1, _1]; _0 = _0.s(_1); return [1, _0]; _ = _ + _0; return [1, _]", true);
test("a*a + await a(await b(await c)).s(await c)", "_ = a * a; _0 = c; return [1, _0]; _0 = b(_0); return [1, _0]; _0 = a(_0); _1 = c; return [1, _1]; _0 = _0.s(_1); return [1, _0]; _ = _ + _0; return [1, _]", true);
test("await a, await b", "_ = a; return [1, _]; _ = b; return [1, _]", true);
test("await a * b, await b", "_ = a; return [1, _]; _ = _ * b; return [1, _]; _ = b; return [1, _]", true);
test("if(a) await b", "if (!a) return [1]; _ = b; return [1, _]", true);
test("if(a) await b; else await c", "if (!a) return [1]; _ = b; return [2, _]; _ = c; return [1, _]", true);
test("if(a) await b; else if(e) await c", "if (!a) return [1]; _ = b; return [2, _]; if (!e) return [1]; _ = c; return [1, _]", true);
test("if(a) await b; else if(e) await c else await d", "if (!a) return [1]; _ = b; return [3, _]; if (!e) return [1]; _ = c; return [2, _]; _ = d; return [1, _]", true);
test("if(await a) await b", "_ = a; return [1, _]; if (!_) return [1]; _ = b; return [1, _]", true);
test("for(a=0;a<10;a++) await a", "a = 0; return [1]; _ = a < 10; if (!_) return [3]; _ = a; return [1, _]; _ = a++; return [-2]", true);
test("for(a=0;a<10;a++) await a, await b", "a = 0; return [1]; _ = a < 10; if (!_) return [4]; _ = a; return [1, _]; _ = b; return [1, _]; _ = a++; return [-3]", true);
test("while(a) await b", "_ = a; if (!_) return [3]; _ = b; return [1, _]; return [-2]", true);
test("do{await b}while(a)", "_ = b; return [1, _]; _ = a; return [_ ? -2 : 1]", true);
test("switch(a){case 1:}", "_ = a; _0 = 1; if (_ === _0) return [1]", true);
test("switch(a){case 1:break;}", "_ = a; _0 = 1; if (_ === _0) return [1]; return [1]", true);
test("switch(a){case 1:break;case 2:break;}", "_ = a; _0 = 1; if (_ === _0) return [2]; _0 = 2; if (_ === _0) return [2]; return [2]; return [1]", true);
test("switch(a){case 1:case 2:break;}", "_ = a; _0 = 1; if (_ === _0) return [2]; _0 = 2; if (_ === _0) return [1]; return [1]", true);
test("switch(a){case 1:case 2:x=1;}", "_ = a; _0 = 1; if (_ === _0) return [2]; _0 = 2; if (_ === _0) return [1]; x = 1", true);
test("switch(a){case 1:case 2:x=1;}", "_ = a; _0 = 1; if (_ === _0) return [2]; _0 = 2; if (_ === _0) return [1]; x = 1", true);
test("with(a){ a = 1}", `_ = a; if (_0 = with_("a", [_])) _0.a = 1; else a = 1;`, true);
