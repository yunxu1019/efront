<style>
    :scope {
        padding: 10px 20px;
        border-radius: 3px;
        display: inline-block;
        background: #2c2c2c;
        color: #d4d4d4;
        font-family: Consolas, "Courier New", monospace;
        vertical-align: top;
    }

    stamp {
        color: #808080;
    }

    strap,
    value {
        color: #569cd6;
    }

    regexp {
        color: #d16969;
    }

    text {
        color: #ce9178;
    }

    flow {
        color: #c586c0;
    }

    digit {
        color: #b5cea8;
    }

    label {
        color: #569cd6;
    }

    @deep(@num, @color) {
        deep@num {
            color: @color;
        }
    }

    @deep(0, #ffd700);
    @deep(1, #da70d6);
    @deep(2, #179fff);
    @deep(3, #ffd700);
    @deep(4, #da70d6);
    @deep(5, #179fff);
    @deep(6, #ffd700);
    @deep(7, #da70d6);
    @deep(8, #179fff);
    @deep(9, #ffd700);
    @deep(10, #da70d6);
    @deep(11, #179fff);
    @deep(12, #ffd700);
    @deep(13, #da70d6);
    @deep(14, #179fff);
    @deep(15, #ffd700);
    @deep(16, #da70d6);
    @deep(17, #179fff);

    express,
    property {
        color: #9cdcfe;
    }

    invoke,
    method {
        color: #dcdcaa;
    }

    predef {
        color: #4ec9b0;
    }

    outside {
        color: #4fc1ff;
    }

    comment {
        color: #6a9955;
    }
</style>
<script>
    var encode = function (text) {
        return text.replace(/[\<\>\|]/g, a => `&#${a.charCodeAt()};`)
    };
    var typescript = new compile$Javascript;
    typescript.straps = typescript.straps.concat("interface", "implements", "declare", "module", "readonly", "enum");
    var js = new compile$Javascript;
    js.keepspace = true;
    var codesupports = {
        javascript(a, blink) {
            if (blink) var index = a.indexOf(blink);
            if (index >= 0) a = a.slice(0, index) + a.slice(index + 1);
            js.keepspace = !!blink;
            var c = compile$scanner2(a, js);
            if (index >= 0) {
                var patched = patchBlink(c, index, blink);
            }
            codecolor(c, encode);
            a = c.toString();
            if (index >= 0 && !patched) a = blink + a;
            return a;
        },
        typescript(a) {
            var c = compile$scanner2(a, typescript);
            codecolor(c, encode);
            return c.toString();
        },
        html(a) {
            var code = compile$scanner2(a, 'html');
            var scoped = code.scoped;
            codecolor(code, encode);
            backEach(scoped.richNodes, n => {
                if (n.isScript) {
                    var js = compile$scanner2(compile$common.createString(n));
                    codecolor(js, encode);
                    n.splice(0, n.length, ...js);
                }
            })
            return code.toString();
        },
        css(a) {
            var c = compile$scanner2(a);
            codecolor(c, encode);
            return c.toString();
        }
    };
    codesupports.cmd = codesupports.bat;
    codesupports.jsx = codesupports.js = codesupports.javascript;
    codesupports.tsx = codesupports.ts = codesupports.typescript;
    codesupports.xml = codesupports.html;
    var { SCOPED, QUOTED } = compile$common;
    var patchBlink = function (code, index, blink) {
        for (var cx = 0, dx = code.length; cx < dx; cx++) {
            var c = code[cx];
            var haschildren = c => c.type === SCOPED || c.type === QUOTED && c.length;
            if (c.start === index) {
                if (haschildren(c)) {
                    c.entry = blink + c.entry;
                }
                else {
                    c.blink = 0;
                    c.text = blink + c.text;
                }
                return true;
            }
            else if (c.start < index && c.end > index) {
                if (haschildren(c)) {
                    return patchBlink(c, index, blink);
                }
                else {
                    c.blink = index - c.start;
                    c.text = c.text.slice(0, c.blink) + blink + c.text.slice(c.blink);

                    return true;
                }
            }
            else if (c.end === index) {
                if (haschildren(c)) {
                    c.leave += blink;
                }
                else {
                    c.blink = c.text.length;
                }
                return true;
            }
            else if (c.start > index) {
                if (cx === 0) {
                    if (code.entry) return code.entry += blink, true;
                    return false;
                }
                else {
                    var p = code[cx - 1];
                    if (haschildren(p)) {
                        p.leave += blink;
                    }
                    else {
                        p.blink = p.text.length;
                        p.text = p.text + blink;
                    }
                    return true;
                }
            }
        }
        if (code.leave) {
            code.leave = blink + code.leave;
            return true;
        }
        return false;
    };
    function codetext(type, text, blink) {
        type = type.toLowerCase();
        if (type in codesupports) {
            text = codesupports[type](text, blink);
        }
        else text = encode(text);
        var codes = text.split(/\r\n|\r|\n/);
        var minSpace = 0;
        for (var c of codes) {
            var m = /^\s*/.exec(c);
            if (m && m[0].length < c.length) {
                minSpace = m[0].length;
            }
        }
        if (minSpace > 0) codes = codes.map(c => /^\s+/.test(c) ? c.slice(minSpace) : c);
        return `<code type=${type}>${codes.join("<br/>").replace(/\t/g, Array(5).join('&ensp;')).replace(/\s/g, '&ensp;')}</code>`;
    }
    codetext.encode = encode;
</script>