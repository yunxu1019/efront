<style>
    :scope {
        white-space: pre-wrap;
        line-height: 1.36;
        word-break: break-all;
        padding: 10px 20px;
        border-radius: 3px;
        display: inline-block;
        background: #2c2c2c;
        color: #d4d4d4;
        font-family: Consolas, "Courier New", monospace;
        vertical-align: top;
        text-decoration-line: none;
        tab-size: 4;
    }

    stamp {
        color: #808080;
    }

    strap,
    value {
        color: #569cd6;
    }

    regexp {
        color: #d16969;
    }

    text {
        color: #ce9178;
    }

    flow {
        color: #c586c0;
    }

    digit {
        color: #b5cea8;
    }

    label {
        color: #569cd6;
    }

    @deep(@num, @color) {
        deep@num {
            color: @color;
        }
    }

    @deep(0, #ffd700);
    @deep(1, #da70d6);
    @deep(2, #179fff);
    @deep(3, #ffd700);
    @deep(4, #da70d6);
    @deep(5, #179fff);
    @deep(6, #ffd700);
    @deep(7, #da70d6);
    @deep(8, #179fff);
    @deep(9, #ffd700);
    @deep(10, #da70d6);
    @deep(11, #179fff);
    @deep(12, #ffd700);
    @deep(13, #da70d6);
    @deep(14, #179fff);
    @deep(15, #ffd700);
    @deep(16, #da70d6);
    @deep(17, #179fff);

    express,
    property {
        color: #9cdcfe;
    }

    invoke,
    method {
        color: #dcdcaa;
    }

    predef {
        color: #4ec9b0;
    }

    outside {
        color: #4fc1ff;
    }

    comment {
        color: #6a9955;
    }
</style>
<script>
    var encode = function (text) {
        return text.replace(/[\<\>\|]/g, a => `&#${a.charCodeAt()};`);
    };
    var typescript = new compile$Javascript;
    typescript.straps = typescript.straps.concat(
        "interface", "implements", "declare", "module", "namespace",
        "readonly", "private", "asserts", "is",
        "enum", "type");
    typescript.tags[0].push("{");
    var js = new compile$Javascript;
    js.tags[0].push("{");
    var json = new compile$Javascript;
    json.inExpress = true;
    var gl = new compile$Javascript;
    gl.straps = gl.straps.concat(
        "in", "out", "inout", "uniform", "buffer", "shared",
        "highp", "mediump", "lowp",
        "invariant", "const", "varying", "attribute",
        "sampler2D", "texture2D",
        "sampler3D", "texture3D",
        "coherent", "volatile", "restrict", "readonly", "writeonly",
        "flat", "noperspective", "smooth",
        "packed", "shared", "std140", "std340", "row_major", "colum_major",
        "location", "set", "binding", "offset", "index", "xfb_buffer", "xfb_offset", "local_size",
        "void",
        'require', 'enable', 'disable', 'warn',
        'struct',
        'float', 'int',
        'vec4', 'vec3', 'vec2',
        'mat4', 'mat3', 'mat2',
        'bool', 'const', 'precision',
        "step", "smoothstep",
        "mix", "clamp"
    );
    var rust = new compile$Javascript;
    rust.powermap = Object.assign({}, rust.powermap);
    rust.powermap["->"] = 0;
    rust.straps = ["let", 'use', 'mut', 'fn', 'if', 'else', 'loop', 'while', 'for', 'in', 'break', 'true', 'false', 'struct', 'enum', 'impl', 'self', 'match', 'pub', 'mod', 'trait'];
    var struct_reg = /^(while|do|for|with|switch|case|default|if|else|try|catch|finally|loop|import|export)$/;

    gl.setType = function (o) {
        var { type } = o;
        var queue = o.queue;
        var last = o.prev;
        if (type & (SCOPED | EXPRESS | PROPERTY)) {
            if (last && last === queue[queue.length - 1] && last.type & (EXPRESS | STRAP | PROPERTY)) {
                last.istype = !struct_reg.test(last.text);
            }
        }
    }
    var codesupports = {
        javascript(a, blink) {
            if (blink) var index = a.indexOf(blink);
            if (index >= 0) a = a.slice(0, index) + a.slice(index + 1);
            var c = compile$scanner2(a, js);
            c.scoped;
            if (index >= 0) {
                var patched = patchBlink(c, index, blink);
            }
            codecolor(c, encode);
            a = c.toString();
            if (index >= 0 && !patched) a = blink + a;
            return a;
        },
        typescript(a) {
            var c = compile$scanner2(a, typescript);
            codecolor(c, encode);
            return c.toString();
        },
        json(a) {
            var c = compile$scanner2(a, json);
            codecolor(c, encode);
            return c.toString();
        },
        rs(a) {
            var c = compile$scanner2(a, rust);
            codecolor(c, encode);
            return c.toString();
        },
        glsl(a) {
            var c = compile$scanner2(a, gl);
            codecolor(c, encode);
            return c.toString();
        },
        html(a) {
            var code = compile$scanner2(a, 'html');
            var scoped = code.scoped;
            backEach(scoped.richNodes, n => {
                if (n.isScript) {
                    var js = [];
                    compile$common.createString(n).replace(/^(\s*\<\!--)([\s\S]*)(--\!?\>\s*)$|^[\s\S]*$/, (m, p, a, f) => {
                        if (!a) {
                            js = compile$scanner2(m);
                        }
                        else {
                            js = compile$scanner2(a);
                            js.unshift(
                                { type: compile$common.COMMENT, text: p },
                            );
                            js.push(
                                { type: compile$common.COMMENT, text: f }
                            );
                        }
                        codecolor(js, encode);
                    });
                    n.splice(0, n.length, ...js);
                }
            })
            codecolor(code, encode);
            return code.toString();
        },
        css(a) {
            var c = compile$scanner2(a);
            codecolor(c, encode);
            return c.toString();
        }
    };
    codesupports.gl = codesupports.glsl;
    codesupports.cmd = codesupports.bat;
    codesupports.cjs = codesupports.mjs = codesupports.jsx = codesupports.js = codesupports.javascript;
    codesupports.tsx = codesupports.ts = codesupports.typescript;
    codesupports.jsp = codesupports.asp = codesupports.php = codesupports.xml = codesupports.html;
    var { SCOPED, QUOTED, SPACE, STRAP, EXPRESS, PROPERTY } = compile$common;
    var patchBlink = function (code, index, blink) {
        for (var cx = 0, dx = code.length; cx < dx; cx++) {
            var c = code[cx];
            var haschildren = c => c.type === SCOPED || c.type === QUOTED && c.length;
            if (c.start === index) {
                if (haschildren(c)) {
                    c.entry = blink + c.entry;
                }
                else {
                    c.blink = 0;
                    c.text = blink + c.text;
                }
                return true;
            }
            else if (c.start < index && c.end > index) {
                if (haschildren(c)) {
                    return patchBlink(c, index, blink);
                }
                else {
                    c.blink = index - c.start;
                    c.text = c.text.slice(0, c.blink) + blink + c.text.slice(c.blink);

                    return true;
                }
            }
            else if (c.end === index) {
                if (haschildren(c)) {
                    c.leave += blink;
                }
                else {
                    c.blink = c.text.length;
                    c.text += blink;
                }
                return true;
            }
            else if (c.start > index) {
                if (cx === 0) {
                    if (code.entry) return code.entry += blink, true;
                    return false;
                }
                else {
                    var p = code[cx - 1];
                    if (haschildren(p)) {
                        p.leave += blink;
                    }
                    else {
                        p.blink = p.text.length;
                        p.text = p.text + blink;
                    }
                    return true;
                }
            }
        }
        if (code.leave) {
            code.leave = blink + code.leave;
            return true;
        }
        if (c) return c.text += blink, true;
        return false;
    };
    var rows = function (type, text, blink) {
        type = type.toLowerCase();
        if (type in codesupports) {
            text = codesupports[type](text, blink);
        }
        else text = encode(text);
        var codes = text.split(/\r\n|\r|\n/);
        var minSpace = 0;
        for (var c of codes) {
            var m = /^\s*/.exec(c);
            if (m && m[0].length < minSpace) {
                minSpace = m[0].length;
            }
        }
        if (minSpace > 0) codes = codes.map(c => /^\s+/.test(c) ? c.slice(minSpace) : c);
        return codes;
    }
    function codetext(type, text, blink) {
        var ws = rows(type, text, blink);
        return `<code type=${type}>${ws.join("<br/>")}</code>`;
    }
    codetext.rows = rows;
    codetext.encode = encode;
</script>