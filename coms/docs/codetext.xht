<style>
    :scope {
        white-space: pre-wrap;
        line-height: 1.36;
        word-break: break-all;
        padding: 10px 20px;
        border-radius: 3px;
        display: inline-block;
        background: #2c2c2c;
        color: #d4d4d4;
        font-family: Consolas, "Courier New", monospace;
        vertical-align: top;
        text-decoration-line: none;
        tab-size: 4;
    }

    stamp {
        color: #808080;
    }

    strap,
    value {
        color: #569cd6;
    }

    regexp {
        color: #d16969;
    }

    text {
        color: #ce9178;
    }

    flow {
        color: #c586c0;
    }

    digit {
        color: #b5cea8;
    }

    label {
        color: #569cd6;
    }

    selector {
        color: #d7ba7d;
    }

    @deep(@num, @color) {
        deep@num {
            color: @color;
        }
    }

    @deep(0, #ffd700);
    @deep(1, #da70d6);
    @deep(2, #179fff);
    @deep(3, #ffd700);
    @deep(4, #da70d6);
    @deep(5, #179fff);
    @deep(6, #ffd700);
    @deep(7, #da70d6);
    @deep(8, #179fff);
    @deep(9, #ffd700);
    @deep(10, #da70d6);
    @deep(11, #179fff);
    @deep(12, #ffd700);
    @deep(13, #da70d6);
    @deep(14, #179fff);
    @deep(15, #ffd700);
    @deep(16, #da70d6);
    @deep(17, #179fff);

    express,
    property {
        color: #9cdcfe;
    }

    invoke,
    method {
        color: #dcdcaa;
    }

    predef {
        color: #4ec9b0;
    }

    outside {
        color: #4fc1ff;
    }

    comment {
        color: #6a9955;
    }
</style>
<script>
    var encode = function (text) {
        return text.replace(/[\<\>\|]/g, a => `&#${a.charCodeAt()};`);
    };
    var typescript = new compile$Javascript;
    typescript.straps = typescript.straps.concat(
        "interface", "implements", "declare", "module", "namespace",
        "readonly", "private", "asserts", "is",
        "enum", "type");
    typescript.tags[0].push("{");
    var js = new compile$Javascript;
    js.tags[0].push("{");
    var json = new compile$Javascript;
    json.inExpress = true;
    var gl = new compile$Javascript;
    gl.straps = gl.straps.concat(
        "in", "out", "inout", "uniform", "buffer", "shared",
        "highp", "mediump", "lowp",
        "invariant", "const", "varying", "attribute",
        "sampler2D", "texture2D",
        "sampler3D", "texture3D",
        "coherent", "volatile", "restrict", "readonly", "writeonly",
        "flat", "noperspective", "smooth",
        "packed", "shared", "std140", "std340", "row_major", "colum_major",
        "location", "set", "binding", "offset", "index", "xfb_buffer", "xfb_offset", "local_size",
        "void",
        'require', 'enable', 'disable', 'warn',
        'struct',
        'float', 'int',
        'vec4', 'vec3', 'vec2',
        'mat4', 'mat3', 'mat2',
        'bool', 'const', 'precision',
        "step", "smoothstep",
        "mix", "clamp"
    );
    var rust = new compile$Javascript;
    rust.powermap = Object.assign({}, rust.powermap);
    rust.powermap["->"] = 0;
    rust.straps = ["let", 'use', 'mut', 'fn', 'if', 'else', 'loop', 'while', 'for', 'in', 'break', 'true', 'false', 'struct', 'enum', 'impl', 'self', 'match', 'pub', 'mod', 'trait'];
    var struct_reg = /^(while|do|for|with|switch|case|default|if|else|try|catch|finally|loop|import|export)$/;

    gl.setType = function (o) {
        var { type } = o;
        var queue = o.queue;
        var last = o.prev;
        if (type & (SCOPED | EXPRESS | PROPERTY)) {
            if (last && last === queue[queue.length - 1] && last.type & (EXPRESS | STRAP | PROPERTY)) {
                last.istype = !struct_reg.test(last.text);
            }
        }
    }
    var 素心 = new compile$素馨.素心;
    素心.scopes.push(['[', ']']);
    素心.straps.push('important',
        'after', 'backdrop', 'before',
        'cue', 'cue-range',
        'file-selector-button', 'first-letter', 'last-letter', 'first-line',
        'grammer-error', 'highlight', 'marker', 'part',
        'placeholder', 'selection', 'slotted', 'spelling-error', 'target-text',
        'view-transition', 'view-transition-group', 'view-transition-image-pair', 'view-transition-new', 'view-transition-old',
        'active', 'any-link', 'autofill',
        'blank',
        'checked', 'current',
        'dir', 'default', 'defined', 'disabled',
        'empty', 'enabled',
        'first', 'first-child', 'first-of-type', 'future', 'focus', 'focus-visible', 'focus-within', 'fullscreen',
        'has', 'host', 'host-context', 'hover',
        'indeterminate', 'in-range', 'invalid', 'is',
        'lang', 'last-child', 'last-of-type', 'left', 'link', 'local-link',
        'modal',
        'not', 'nth-child', 'nth-col', 'nth-last-child', 'nth-last-col', 'nth-last-of-type', 'nth-of-type',
        "only-child", 'only-of-type', 'optional', 'out-of-range',
        'past', 'picture-in-picture', 'placeholder-shown', 'paused', 'playing',
        'read-only', 'read-write', 'required', 'right', 'root',
        'scope', 'state',
        'target', 'target-within',
        'user-invalid',
        'valid', 'visited',
        'where'
    );
    素心.stamps.push("=");
    var setless = function (c) {
        var set = function (o) {
            if (o.type === PROPERTY) {
                var q = o.queue;
                if (q.type === SCOPED && q.entry !== "{") return;
                var next = o.next;
                if (next && (next.type !== STAMP || !/^[\:\=]$/.test(next.text))) {
                    o.text = `<selector>${o.text}</selector>`;
                    return;
                }
                if (next && (next.type === STAMP && next.text === ':')) {
                    while (next && next.type !== SCOPED) {
                        if (next.type === STAMP && next.text === ';') return;
                        next = next.next;
                    }
                    if (next) o.text = `<selector>${o.text}</selector>`;
                }
                return;
            }
            if (o.type === EXPRESS) {
                var next = o.next;
                if (next?.type === SCOPED) return;
                if (!o.length) o.type = QUOTED;
                return;
            }
            if (o.type === STRAP) {
                if (!o.isprop) return o.type = EXPRESS;
                var p = o.prev;
                if (!/^@/.test(o.text) && (!p || p.type !== STAMP || !/\:$/.test(p.text))) o.type = PROPERTY;
                return;
            }

            if (o.type === SCOPED && o.length) {
                o.forEach(set);
            }
        };
        c.forEach(set);
    };
    var codesupports = {
        javascript(a, blink) {
            if (blink) var index = a.indexOf(blink);
            if (index >= 0) a = a.slice(0, index) + a.slice(index + 1);
            var c = compile$scanner2(a, js);
            c.scoped;
            if (index >= 0) {
                var patched = patchBlink(c, index, blink);
            }
            codecolor(c, encode);
            a = c.toString();
            if (index >= 0 && !patched) a = blink + a;
            return a;
        },
        typescript(a) {
            var c = compile$scanner2(a, typescript);
            codecolor(c, encode);
            return c.toString();
        },
        json(a) {
            var c = compile$scanner2(a, json);
            codecolor(c, encode);
            return c.toString();
        },
        less(a) {
            var c = compile$scanner2(a, 素心);
            setless(c);
            codecolor(c, encode);
            return c.toString();
        },
        rs(a) {
            var c = compile$scanner2(a, rust);
            codecolor(c, encode);
            return c.toString();
        },
        glsl(a) {
            var c = compile$scanner2(a, gl);
            codecolor(c, encode);
            return c.toString();
        },
        html(a) {
            var code = compile$scanner2(a, 'html');
            var scoped = code.scoped;
            backEach(scoped.richNodes, n => {
                if (n.isScript || n.isStyle) {
                    var s = n.isScript ? js : 素心;
                    var c = [];
                    compile$common.createString(n).replace(/^(\s*\<\!--)([\s\S]*)(--\!?\>\s*)$|^[\s\S]*$/, (m, p, a, f) => {
                        if (!a) {
                            c = compile$scanner2(m, s);
                        }
                        else {
                            c = compile$scanner2(a, s);
                            c.unshift(
                                { type: compile$common.COMMENT, text: p },
                            );
                            c.push(
                                { type: compile$common.COMMENT, text: f }
                            );
                        }
                        if (n.isStyle) setless(c);
                        codecolor(c, encode);
                    });
                    n.splice(0, n.length, ...c);
                }
            })
            codecolor(code, encode);
            return code.toString();
        },
        css(a) {
            var c = compile$scanner2(a);
            codecolor(c, encode);
            return c.toString();
        }
    };
    codesupports.gl = codesupports.glsl;
    codesupports.cmd = codesupports.bat;
    codesupports.css = codesupports.less;
    codesupports.cjs = codesupports.mjs = codesupports.jsx = codesupports.js = codesupports.javascript;
    codesupports.tsx = codesupports.ts = codesupports.typescript;
    codesupports.xht = codesupports.jsp = codesupports.asp = codesupports.php = codesupports.xml = codesupports.html;
    codesupports.vue = codesupports.xht;
    var { SCOPED, QUOTED, SPACE, STAMP, STRAP, EXPRESS, PROPERTY } = compile$common;
    var patchBlink = function (code, index, blink) {
        for (var cx = 0, dx = code.length; cx < dx; cx++) {
            var c = code[cx];
            var haschildren = c => c.type === SCOPED || c.type === QUOTED && c.length;
            if (c.start === index) {
                if (haschildren(c)) {
                    c.entry = blink + c.entry;
                }
                else {
                    c.blink = 0;
                    c.text = blink + c.text;
                }
                return true;
            }
            else if (c.start < index && c.end > index) {
                if (haschildren(c)) {
                    return patchBlink(c, index, blink);
                }
                else {
                    c.blink = index - c.start;
                    c.text = c.text.slice(0, c.blink) + blink + c.text.slice(c.blink);

                    return true;
                }
            }
            else if (c.end === index) {
                if (haschildren(c)) {
                    c.leave += blink;
                }
                else {
                    c.blink = c.text.length;
                    c.text += blink;
                }
                return true;
            }
            else if (c.start > index) {
                if (cx === 0) {
                    if (code.entry) return code.entry += blink, true;
                    return false;
                }
                else {
                    var p = code[cx - 1];
                    if (haschildren(p)) {
                        p.leave += blink;
                    }
                    else {
                        p.blink = p.text.length;
                        p.text = p.text + blink;
                    }
                    return true;
                }
            }
        }
        if (code.leave) {
            code.leave = blink + code.leave;
            return true;
        }
        if (c) return c.text += blink, true;
        return false;
    };
    var rows = function (type, text, blink) {
        type = type.toLowerCase();
        if (type in codesupports) {
            text = codesupports[type](text, blink);
        }
        else text = encode(text);
        var codes = text.split(/\r\n|\r|\n/);
        var minSpace = Infinity;
        for (var c of codes) {
            var m = /^\s+/.exec(c);
            if (!m) {
                minSpace = 0;
                break;
            }
            if (m[0].length < minSpace) {
                minSpace = m[0].length;
            }
        }
        if (minSpace > 0 && minSpace < Infinity) codes = codes.map(c => /^\s+/.test(c) ? c.slice(minSpace) : c);
        return codes;
    }
    function codetext(type, text, blink) {
        var ws = rows(type, text, blink);
        return `<code type=${type}>${ws.join("<br/>")}</code>`;
    }
    codetext.rows = rows;
    codetext.encode = encode;
</script>