// Generated by CommonJS Justhere 1.0.1
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  var process = function () {
      var cwd = '/';
      return {
        title: 'browser',
        version: 'v12.20.0',
        browser: true,
        env: {},
        argv: [],
        nextTick: global.setImmediate || function (fn) {
          setTimeout(fn, 0);
        },
        cwd: function () {
          return cwd;
        },
        chdir: function (dir) {
          cwd = dir;
        }
      };
    }();
  require.define('/esmangle/lib/esmangle.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var esshorten, common, Options, Syntax, Pass, annotateDirective;
      esshorten = require('/esshorten/lib/esshorten.js', module);
      common = require('/esmangle/lib/common.js', module);
      Options = require('/esmangle/lib/options.js', module);
      Pass = require('/esmangle/lib/pass.js', module);
      annotateDirective = require('/esmangle/lib/annotate-directive.js', module);
      Syntax = common.Syntax;
      function recover(tree, useDirectiveStatement) {
        function trailingIf(node) {
          while (true) {
            switch (node.type) {
            case Syntax.IfStatement:
              if (!node.alternate) {
                return true;
              }
              node = node.alternate;
              continue;
            case Syntax.LabeledStatement:
            case Syntax.ForStatement:
            case Syntax.ForInStatement:
            case Syntax.WhileStatement:
            case Syntax.WithStatement:
              node = node.body;
              continue;
            }
            return false;
          }
        }
        common.traverse(tree, {
          leave: function leave(node) {
            if (node.type === Syntax.IfStatement && node.alternate) {
              if (node.consequent.type !== Syntax.BlockStatement) {
                if (trailingIf(node.consequent)) {
                  node.consequent = {
                    type: Syntax.BlockStatement,
                    body: [node.consequent]
                  };
                }
              }
            }
            if (!useDirectiveStatement && node.type === Syntax.DirectiveStatement) {
              node.type = Syntax.ExpressionStatement;
              node.expression = common.moveLocation(node, {
                type: Syntax.Literal,
                value: node.value,
                raw: node.raw
              });
              delete node.directive;
              delete node.value;
              delete node.raw;
            }
          }
        });
        return tree;
      }
      function iteration(tree, p, options) {
        var i, iz, pass, res, changed, statuses, passes, result;
        function addPass(pass) {
          var name;
          if (typeof pass !== 'function') {
            name = Object.keys(pass)[0];
            pass = pass[name];
          }
          if (pass.hasOwnProperty('passName')) {
            name = pass.passName;
          } else {
            name = pass.name;
          }
          passes.push(pass);
          statuses.push(true);
        }
        function fillStatuses(bool) {
          var i, iz;
          for (i = 0, iz = statuses.length; i < iz; ++i) {
            statuses[i] = bool;
          }
        }
        result = options.get('destructive') ? tree : common.deepCopy(tree);
        statuses = [];
        passes = [];
        for (i = 0, iz = p.length; i < iz; ++i) {
          addPass(p[i]);
        }
        do {
          changed = false;
          for (i = 0, iz = passes.length; i < iz; ++i) {
            pass = passes[i];
            if (statuses[i]) {
              res = pass(result, options);
              if (res.modified) {
                changed = true;
                fillStatuses(true);
              } else {
                statuses[i] = false;
              }
              result = res.result;
            }
          }
        } while (changed);
        return result;
      }
      function optimize(tree, pipeline, options) {
        var i, iz, j, jz, section, pass;
        tree = annotateDirective(tree, new Options({ destructive: false }));
        if (null == pipeline) {
          pipeline = Pass.__defaultPipeline;
        }
        options = new Options(options);
        for (i = 0, iz = pipeline.length; i < iz; ++i) {
          section = pipeline[i];
          if (common.Array.isArray(section)) {
            tree = iteration(tree, section, options);
          } else if (section.once) {
            pass = section.pass;
            for (j = 0, jz = pass.length; j < jz; ++j) {
              tree = pass[j](tree, options).result;
            }
          }
        }
        return recover(tree, options.get('directive'));
      }
      exports.version = require('/esmangle/package.json', module).version;
      exports.mangle = esshorten.mangle;
      exports.optimize = optimize;
      exports.pass = Pass;
    }());
  });
  require.define('/esmangle/package.json', function (module, exports, __dirname, __filename) {
    module.exports = {
      '_from': 'esmangle@latest',
      '_id': 'esmangle@1.0.1',
      '_inBundle': false,
      '_integrity': 'sha1-2bs3uPjq+/Tm1O1reqKVarvTxMI=',
      '_location': '/esmangle',
      '_phantomChildren': {},
      '_requested': {
        'type': 'tag',
        'registry': true,
        'raw': 'esmangle@latest',
        'name': 'esmangle',
        'escapedName': 'esmangle',
        'rawSpec': 'latest',
        'saveSpec': null,
        'fetchSpec': 'latest'
      },
      '_requiredBy': [
        '#USER',
        '/'
      ],
      '_resolved': 'https://registry.npm.taobao.org/esmangle/download/esmangle-1.0.1.tgz',
      '_shasum': 'd9bb37b8f8eafbf4e6d4ed6b7aa2956abbd3c4c2',
      '_spec': 'esmangle@latest',
      '_where': 'D:\\work\\efront',
      'bin': { 'esmangle': 'bin/esmangle.js' },
      'bugs': { 'url': 'https://github.com/Constellation/esmangle/issues' },
      'bundleDependencies': false,
      'dependencies': {
        'escodegen': '~1.3.2',
        'escope': '~1.0.1',
        'esprima': '~1.1.1',
        'esshorten': '~1.1.0',
        'estraverse': '~1.5.0',
        'esutils': '~ 1.0.0',
        'optionator': '~0.3.0',
        'source-map': '~0.1.33'
      },
      'deprecated': false,
      'description': 'ECMAScript code mangler / minifier',
      'devDependencies': {
        'async': '~0.2.9',
        'chai': '*',
        'clone': '~0.1.11',
        'commonjs-everywhere': '~0.9.4',
        'grunt': '~0.4.2',
        'grunt-cli': '~0.1.11',
        'grunt-contrib-clean': '~0.5.0',
        'grunt-contrib-copy': '~0.5.0',
        'grunt-contrib-jshint': '~0.8.0',
        'grunt-mocha-test': '~0.8.1',
        'grunt-shell': '~0.6.1',
        'grunt-update-submodules': '~0.2.1',
        'q': '~0.9.7'
      },
      'directories': { 'lib': './lib' },
      'engines': { 'node': '>=0.6.0' },
      'homepage': 'http://github.com/Constellation/esmangle.html',
      'licenses': [{
          'type': 'BSD',
          'url': 'http://github.com/Constellation/esmangle/raw/master/LICENSE.BSD'
        }],
      'main': 'lib/esmangle.js',
      'maintainers': [{
          'name': 'Yusuke Suzuki',
          'email': 'utatane.tea@gmail.com',
          'url': 'http://github.com/Constellation'
        }],
      'name': 'esmangle',
      'repository': {
        'type': 'git',
        'url': 'git+ssh://git@github.com/Constellation/esmangle.git'
      },
      'scripts': {
        'build': 'grunt build',
        'lint': 'grunt lint',
        'regression-test': 'grunt test:regression',
        'test': 'grunt travis',
        'unit-test': 'grunt test'
      },
      'version': '1.0.1'
    };
  });
  require.define('/esmangle/lib/annotate-directive.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common;
      Name = 'annotate-directive';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function isDirective(stmt) {
        var expr;
        if (stmt.type === Syntax.ExpressionStatement) {
          expr = stmt.expression;
          if (expr.type === Syntax.Literal && typeof expr.value === 'string') {
            return true;
          }
        }
        return false;
      }
      function escapeAllowedCharacter(ch, next) {
        var code = ch.charCodeAt(0), hex = code.toString(16), result = '\\';
        switch (ch) {
        case '\b':
          result += 'b';
          break;
        case '\f':
          result += 'f';
          break;
        case '\t':
          result += 't';
          break;
        default:
          if (code > 255) {
            result += 'u' + '0000'.slice(hex.length) + hex;
          } else if (ch === '\0' && '0123456789'.indexOf(next) < 0) {
            result += '0';
          } else if (ch === '\x0B') {
            result += 'v';
          } else {
            result += 'x' + '00'.slice(hex.length) + hex;
          }
          break;
        }
        return result;
      }
      function escapeDisallowedCharacter(ch) {
        var result = '\\';
        switch (ch) {
        case '\\':
          result += '\\';
          break;
        case '\n':
          result += 'n';
          break;
        case '\r':
          result += 'r';
          break;
        case '\u2028':
          result += 'u2028';
          break;
        case '\u2029':
          result += 'u2029';
          break;
        default:
          throw new Error('Incorrectly classified character');
        }
        return result;
      }
      function escapeString(str) {
        var result = '', i, len, ch;
        if (typeof str[0] === 'undefined') {
          str = common.stringToArray(str);
        }
        for (i = 0, len = str.length; i < len; i += 1) {
          ch = str[i];
          if (ch === "'") {
            result += "\\'";
            continue;
          } else if ('\\\n\r\u2028\u2029'.indexOf(ch) >= 0) {
            result += escapeDisallowedCharacter(ch);
            continue;
          } else if (!(ch >= ' ' && ch <= '~')) {
            result += escapeAllowedCharacter(ch, str[i + 1]);
            continue;
          }
          result += ch;
        }
        return result;
      }
      function annotateDirective(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        common.traverse(result, {
          enter: function enter(node, parent) {
            var stmt, i, iz;
            if (!(node.type === Syntax.Program || node.type === Syntax.BlockStatement && (parent.type === Syntax.FunctionExpression || parent.type === Syntax.FunctionDeclaration))) {
              return;
            }
            for (i = 0, iz = node.body.length; i < iz; ++i) {
              stmt = node.body[i];
              if (isDirective(stmt)) {
                stmt.type = Syntax.DirectiveStatement;
                if (stmt.expression.raw) {
                  stmt.directive = stmt.expression.raw.substring(1, stmt.expression.raw.length - 1);
                  stmt.value = stmt.expression.value;
                  stmt.raw = stmt.expression.raw;
                } else {
                  stmt.directive = escapeString(stmt.expression.value);
                  stmt.value = stmt.expression.value;
                  stmt.raw = "'" + stmt.directive + "'";
                }
                delete stmt.expression;
              } else {
                return;
              }
            }
          }
        });
        return result;
      }
      annotateDirective.passName = Name;
      module.exports = annotateDirective;
    }());
  });
  require.define('/esmangle/lib/common.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Syntax, isArray, arrayFrom, arrayOf, has, sameValue, estraverse, escope, esutils;
      estraverse = require('/estraverse/estraverse.js', module);
      escope = require('/escope/escope.js', module);
      esutils = require('/esutils/lib/utils.js', module);
      Syntax = estraverse.Syntax;
      isArray = Array.isArray;
      if (!isArray) {
        isArray = function isArray(array) {
          return Object.prototype.toString.call(array) === '[object Array]';
        };
      }
      function isObject(obj) {
        return typeof obj === 'object' && obj !== null;
      }
      has = function () {
        var method = {}.hasOwnProperty;
        return function has(obj, prop) {
          return method.call(obj, prop);
        };
      }();
      arrayFrom = function () {
        var slice = Array.prototype.slice;
        return function arrayFrom(array) {
          return slice.call(array);
        };
      }();
      arrayOf = function () {
        var slice = Array.prototype.slice;
        return function arrayOf() {
          return slice.call(arguments);
        };
      }();
      function arrayLast(array) {
        return array[array.length - 1];
      }
      function arrayEmpty(array) {
        return array.length === 0;
      }
      function stringRepeat(str, num) {
        var result = '';
        for (num |= 0; num > 0; num >>>= 1, str += str) {
          if (num & 1) {
            result += str;
          }
        }
        return result;
      }
      if (Object.is) {
        sameValue = Object.is;
      } else {
        sameValue = function sameValue(x, y) {
          if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
          }
          return x !== x && y !== y;
        };
      }
      function deepCopy(obj) {
        function deepCopyInternal(obj, result) {
          var key, val;
          for (key in obj) {
            if (key.lastIndexOf('__', 0) === 0) {
              continue;
            }
            if (obj.hasOwnProperty(key)) {
              val = obj[key];
              if (typeof val === 'object' && val !== null) {
                if (val instanceof RegExp) {
                  val = new RegExp(val);
                } else {
                  val = deepCopyInternal(val, isArray(val) ? [] : {});
                }
              }
              result[key] = val;
            }
          }
          return result;
        }
        return deepCopyInternal(obj, isArray(obj) ? [] : {});
      }
      function assert(cond, text) {
        if (!cond) {
          throw new Error(text);
        }
      }
      function unreachable() {
        throw new Error('Unreachable point. logically broken.');
      }
      function isIdentifier(name) {
        if (esutils.keyword.isKeywordES5(name, true) || esutils.keyword.isRestrictedWord(name)) {
          return false;
        }
        return esutils.keyword.isIdentifierName(name);
      }
      function mayBeCompletionValue(node, ancestors) {
        var i, ancestor;
        if (node.type !== Syntax.ExpressionStatement) {
          return true;
        }
        for (i = ancestors.length - 1; i >= 0; --i, node = ancestor) {
          ancestor = ancestors[i];
          switch (ancestor.type) {
          case Syntax.FunctionExpression:
          case Syntax.FunctionDeclaration:
            return false;
          case Syntax.BlockStatement:
          case Syntax.Program:
            if (arrayLast(ancestor.body) !== node) {
              return false;
            }
            break;
          case Syntax.SwitchCase:
            if (arrayLast(ancestor.consequent) !== node) {
              return false;
            }
            break;
          }
        }
        return true;
      }
      function moveLocation(from, to) {
        if (from.loc == null) {
          return to;
        }
        to.loc = deepCopy(from.loc);
        return to;
      }
      function deleteLocation(node) {
        if (node.hasOwnProperty('loc')) {
          return delete node.loc;
        }
        return false;
      }
      function convertToEmptyStatement(node) {
        var i, iz, keys;
        keys = estraverse.VisitorKeys[node.type];
        for (i = 0, iz = keys.length; i < iz; ++i) {
          delete node[keys[i]];
        }
        node.type = Syntax.EmptyStatement;
        return node;
      }
      function isNegative(value) {
        return value === value && (value < 0 || value === 0 && 1 / value < 0);
      }
      function isFunctionBody(node, parent) {
        return node.type === Syntax.BlockStatement && (parent.type === Syntax.FunctionDeclaration || parent.type === Syntax.FunctionExpression);
      }
      function isNumberLiteral(node) {
        return node.type === Syntax.Literal && typeof node.value === 'number';
      }
      function isOptimizedArgument(argument) {
        return isNumberLiteral(argument) && String(argument.value).length === 1;
      }
      function generateNegativeNode(value, node) {
        var result;
        result = {
          type: Syntax.UnaryExpression,
          operator: '-',
          argument: {
            type: Syntax.Literal,
            value: -value
          }
        };
        return node ? moveLocation(node, result) : result;
      }
      function isNegativeNode(node) {
        return node.type === Syntax.UnaryExpression && node.operator === '-' && isNumberLiteral(node.argument);
      }
      function generateUndefined(node) {
        var result = {
            type: Syntax.UnaryExpression,
            operator: 'void',
            argument: {
              type: Syntax.Literal,
              value: 0
            }
          };
        return node ? moveLocation(node, result) : result;
      }
      function isUndefined(node) {
        return node.type === Syntax.UnaryExpression && node.operator === 'void' && isOptimizedArgument(node.argument);
      }
      function generateNaN(node) {
        var result = {
            type: Syntax.BinaryExpression,
            operator: '/',
            left: {
              type: Syntax.Literal,
              value: 0
            },
            right: {
              type: Syntax.Literal,
              value: 0
            }
          };
        return node ? moveLocation(node, result) : result;
      }
      function isNaNNode(node) {
        if (node.type === Syntax.BinaryExpression) {
          if (isOptimizedArgument(node.left) && isOptimizedArgument(node.right)) {
            return node.left.value === 0 && node.right.value === 0;
          }
        }
        return false;
      }
      function generateFromValue(value) {
        if (typeof value === 'number') {
          if (isNaN(value)) {
            return generateNaN();
          }
          if (isNegative(value)) {
            return generateNegativeNode(value);
          }
        }
        if (value === undefined) {
          return generateUndefined();
        }
        return {
          type: Syntax.Literal,
          value: value
        };
      }
      function isReference(node) {
        var type = node.type;
        return type === Syntax.Identifier || type === Syntax.MemberExpression;
      }
      function canExtractSequence(last, parent, scope) {
        var ref;
        if (parent.type === Syntax.CallExpression) {
          if (last.type === Syntax.Identifier) {
            if (last.name === 'eval') {
              return false;
            }
            ref = scope.resolve(last);
            return ref && ref.isStatic();
          }
          return last.type !== Syntax.MemberExpression;
        } else if (parent.type === Syntax.UnaryExpression) {
          if (parent.operator === 'delete') {
            return !isReference(last);
          } else if (parent.operator === 'typeof') {
            if (last.type === Syntax.Identifier) {
              ref = scope.resolve(last);
              return ref && ref.isStatic();
            }
          }
        } else if (parent.type === Syntax.UpdateExpression) {
          return !isReference(last);
        }
        return true;
      }
      function delegateVariableDeclarations(stmt, func) {
        var decls, target;
        decls = [];
        estraverse.traverse(stmt, {
          enter: function (node) {
            var i, iz, decl;
            if (node.type === Syntax.VariableDeclaration) {
              if (node.kind === 'let' || node.kind === 'const') {
                return;
              }
              for (i = 0, iz = node.declarations.length; i < iz; ++i) {
                decl = node.declarations[i];
                delete decl.init;
                decls.push(decl);
              }
              return estraverse.VisitorOption.Skip;
            } else if (escope.Scope.isVariableScopeRequired(node)) {
              return estraverse.VisitorOption.Skip;
            }
          }
        });
        if (!decls.length) {
          return null;
        }
        target = null;
        estraverse.traverse(func.body, {
          enter: function (node, parent) {
            if (node === stmt) {
              return estraverse.VisitorOption.Skip;
            } else if (escope.Scope.isVariableScopeRequired(node)) {
              return estraverse.VisitorOption.Skip;
            } else if (node.type === Syntax.VariableDeclaration && node.kind === 'var') {
              if (parent.type !== Syntax.ForInStatement) {
                target = node;
                return estraverse.VisitorOption.Break;
              }
            }
          }
        });
        if (target) {
          target.declarations = target.declarations.concat(decls);
          return null;
        } else {
          return {
            type: Syntax.VariableDeclaration,
            kind: 'var',
            declarations: decls
          };
        }
      }
      function isScopedDeclaration(node) {
        if (node.type === Syntax.VariableDeclaration && (node.kind === 'let' || node.kind === 'const')) {
          return true;
        } else if (node.type === Syntax.FunctionDeclaration) {
          return true;
        }
        return false;
      }
      exports.deepCopy = deepCopy;
      exports.stringRepeat = stringRepeat;
      exports.sameValue = sameValue;
      exports.Array = {
        isArray: isArray,
        from: arrayFrom,
        of: arrayOf,
        last: arrayLast,
        empty: arrayEmpty
      };
      exports.Object = {
        isObject: isObject,
        has: has
      };
      exports.Syntax = Syntax;
      exports.traverse = estraverse.traverse;
      exports.replace = estraverse.replace;
      exports.VisitorKeys = estraverse.VisitorKeys;
      exports.VisitorOption = estraverse.VisitorOption;
      exports.assert = assert;
      exports.unreachable = unreachable;
      exports.isIdentifier = isIdentifier;
      exports.moveLocation = moveLocation;
      exports.deleteLocation = deleteLocation;
      exports.convertToEmptyStatement = convertToEmptyStatement;
      exports.mayBeCompletionValue = mayBeCompletionValue;
      exports.isNegative = isNegative;
      exports.isFunctionBody = isFunctionBody;
      exports.SpecialNode = {
        generateNegative: generateNegativeNode,
        isNegative: isNegativeNode,
        generateUndefined: generateUndefined,
        isUndefined: isUndefined,
        generateNaN: generateNaN,
        isNaN: isNaNNode,
        isReference: isReference,
        canExtractSequence: canExtractSequence,
        generateFromValue: generateFromValue
      };
      exports.delegateVariableDeclarations = delegateVariableDeclarations;
      exports.isScopedDeclaration = isScopedDeclaration;
    }());
  });
  require.define('/esutils/lib/utils.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      exports.code = require('/esutils/lib/code.js', module);
      exports.keyword = require('/esutils/lib/keyword.js', module);
    }());
  });
  require.define('/esutils/lib/keyword.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var code = require('/esutils/lib/code.js', module);
      function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
          return true;
        default:
          return false;
        }
      }
      function isKeywordES5(id, strict) {
        if (!strict && id === 'yield') {
          return false;
        }
        return isKeywordES6(id, strict);
      }
      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }
        switch (id.length) {
        case 2:
          return id === 'if' || id === 'in' || id === 'do';
        case 3:
          return id === 'var' || id === 'for' || id === 'new' || id === 'try';
        case 4:
          return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
        case 5:
          return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
        case 6:
          return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
        case 7:
          return id === 'default' || id === 'finally' || id === 'extends';
        case 8:
          return id === 'function' || id === 'continue' || id === 'debugger';
        case 10:
          return id === 'instanceof';
        default:
          return false;
        }
      }
      function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
      }
      function isIdentifierName(id) {
        var i, iz, ch;
        if (id.length === 0) {
          return false;
        }
        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {
          return false;
        }
        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (!code.isIdentifierPart(ch) || ch === 92) {
            return false;
          }
        }
        return true;
      }
      module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName
      };
    }());
  });
  require.define('/esutils/lib/code.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Regex;
      Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      function isHexDigit(ch) {
        return isDecimalDigit(ch) || 97 <= ch && ch <= 102 || 65 <= ch && ch <= 70;
      }
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      function isWhiteSpace(ch) {
        return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && [
          5760,
          6158,
          8192,
          8193,
          8194,
          8195,
          8196,
          8197,
          8198,
          8199,
          8200,
          8201,
          8202,
          8239,
          8287,
          12288,
          65279
        ].indexOf(ch) >= 0;
      }
      function isLineTerminator(ch) {
        return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
      }
      function isIdentifierStart(ch) {
        return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
      }
      function isIdentifierPart(ch) {
        return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
      }
      module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
      };
    }());
  });
  require.define('/escope/escope.js', function (module, exports, __dirname, __filename) {
    (function (factory, global) {
      'use strict';
      function namespace(str, obj) {
        var i, iz, names, name;
        names = str.split('.');
        for (i = 0, iz = names.length; i < iz; ++i) {
          name = names[i];
          if (obj.hasOwnProperty(name)) {
            obj = obj[name];
          } else {
            obj = obj[name] = {};
          }
        }
        return obj;
      }
      if (typeof define === 'function' && define.amd) {
        define('escope', [
          'exports',
          'estraverse'
        ], function (exports, estraverse) {
          factory(exports, global, estraverse);
        });
      } else if (typeof exports !== 'undefined') {
        factory(exports, global, require('/escope/node_modules/estraverse/estraverse.js', module));
      } else {
        factory(namespace('escope', global), global, global.estraverse);
      }
    }(function (exports, global, estraverse) {
      'use strict';
      var Syntax, Map, currentScope, globalScope, scopes, options;
      Syntax = estraverse.Syntax;
      if (typeof global.Map !== 'undefined') {
        Map = global.Map;
      } else {
        Map = function Map() {
          this.__data = {};
        };
        Map.prototype.get = function MapGet(key) {
          key = '$' + key;
          if (this.__data.hasOwnProperty(key)) {
            return this.__data[key];
          }
          return undefined;
        };
        Map.prototype.has = function MapHas(key) {
          key = '$' + key;
          return this.__data.hasOwnProperty(key);
        };
        Map.prototype.set = function MapSet(key, val) {
          key = '$' + key;
          this.__data[key] = val;
        };
        Map.prototype['delete'] = function MapDelete(key) {
          key = '$' + key;
          return delete this.__data[key];
        };
      }
      function assert(cond, text) {
        if (!cond) {
          throw new Error(text);
        }
      }
      function defaultOptions() {
        return {
          optimistic: false,
          directive: false,
          ecmaVersion: 5
        };
      }
      function updateDeeply(target, override) {
        var key, val;
        function isHashObject(target) {
          return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }
        for (key in override) {
          if (override.hasOwnProperty(key)) {
            val = override[key];
            if (isHashObject(val)) {
              if (isHashObject(target[key])) {
                updateDeeply(target[key], val);
              } else {
                target[key] = updateDeeply({}, val);
              }
            } else {
              target[key] = val;
            }
          }
        }
        return target;
      }
      function Reference(ident, scope, flag, writeExpr, maybeImplicitGlobal) {
        this.identifier = ident;
        this.from = scope;
        this.tainted = false;
        this.resolved = null;
        this.flag = flag;
        if (this.isWrite()) {
          this.writeExpr = writeExpr;
        }
        this.__maybeImplicitGlobal = maybeImplicitGlobal;
      }
      Reference.READ = 1;
      Reference.WRITE = 2;
      Reference.RW = 3;
      Reference.prototype.isStatic = function isStatic() {
        return !this.tainted && this.resolved && this.resolved.scope.isStatic();
      };
      Reference.prototype.isWrite = function isWrite() {
        return this.flag & Reference.WRITE;
      };
      Reference.prototype.isRead = function isRead() {
        return this.flag & Reference.READ;
      };
      Reference.prototype.isReadOnly = function isReadOnly() {
        return this.flag === Reference.READ;
      };
      Reference.prototype.isWriteOnly = function isWriteOnly() {
        return this.flag === Reference.WRITE;
      };
      Reference.prototype.isReadWrite = function isReadWrite() {
        return this.flag === Reference.RW;
      };
      function Variable(name, scope) {
        this.name = name;
        this.identifiers = [];
        this.references = [];
        this.defs = [];
        this.tainted = false;
        this.stack = true;
        this.scope = scope;
      }
      Variable.CatchClause = 'CatchClause';
      Variable.Parameter = 'Parameter';
      Variable.FunctionName = 'FunctionName';
      Variable.Variable = 'Variable';
      Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';
      function isStrictScope(scope, block) {
        var body, i, iz, stmt, expr;
        if (scope.upper && scope.upper.isStrict) {
          return true;
        }
        if (scope.type === 'function') {
          body = block.body;
        } else if (scope.type === 'global') {
          body = block;
        } else {
          return false;
        }
        if (options.directive) {
          for (i = 0, iz = body.body.length; i < iz; ++i) {
            stmt = body.body[i];
            if (stmt.type !== 'DirectiveStatement') {
              break;
            }
            if (stmt.raw === '"use strict"' || stmt.raw === "'use strict'") {
              return true;
            }
          }
        } else {
          for (i = 0, iz = body.body.length; i < iz; ++i) {
            stmt = body.body[i];
            if (stmt.type !== Syntax.ExpressionStatement) {
              break;
            }
            expr = stmt.expression;
            if (expr.type !== Syntax.Literal || typeof expr.value !== 'string') {
              break;
            }
            if (expr.raw != null) {
              if (expr.raw === '"use strict"' || expr.raw === "'use strict'") {
                return true;
              }
            } else {
              if (expr.value === 'use strict') {
                return true;
              }
            }
          }
        }
        return false;
      }
      function Scope(block, opt) {
        var variable, body;
        this.type = block.type === Syntax.CatchClause ? 'catch' : block.type === Syntax.WithStatement ? 'with' : block.type === Syntax.Program ? 'global' : 'function';
        this.set = new Map;
        this.taints = new Map;
        this.dynamic = this.type === 'global' || this.type === 'with';
        this.block = block;
        this.through = [];
        this.variables = [];
        this.references = [];
        this.left = [];
        this.variableScope = this.type === 'global' || this.type === 'function' ? this : currentScope.variableScope;
        this.functionExpressionScope = false;
        this.directCallToEvalScope = false;
        this.thisFound = false;
        body = this.type === 'function' ? block.body : block;
        if (opt.naming) {
          this.__define(block.id, {
            type: Variable.FunctionName,
            name: block.id,
            node: block
          });
          this.functionExpressionScope = true;
        } else {
          if (this.type === 'function') {
            variable = new Variable('arguments', this);
            this.taints.set('arguments', true);
            this.set.set('arguments', variable);
            this.variables.push(variable);
          }
          if (block.type === Syntax.FunctionExpression && block.id) {
            new Scope(block, { naming: true });
          }
        }
        this.upper = currentScope;
        this.isStrict = isStrictScope(this, block);
        this.childScopes = [];
        if (currentScope) {
          currentScope.childScopes.push(this);
        }
        currentScope = this;
        if (this.type === 'global') {
          globalScope = this;
          globalScope.implicit = {
            set: new Map,
            variables: []
          };
        }
        scopes.push(this);
      }
      Scope.prototype.__close = function __close() {
        var i, iz, ref, current, node, implicit;
        if (!this.dynamic || options.optimistic) {
          for (i = 0, iz = this.left.length; i < iz; ++i) {
            ref = this.left[i];
            if (!this.__resolve(ref)) {
              this.__delegateToUpperScope(ref);
            }
          }
        } else {
          if (this.type === 'with') {
            for (i = 0, iz = this.left.length; i < iz; ++i) {
              ref = this.left[i];
              ref.tainted = true;
              this.__delegateToUpperScope(ref);
            }
          } else {
            for (i = 0, iz = this.left.length; i < iz; ++i) {
              ref = this.left[i];
              current = this;
              do {
                current.through.push(ref);
                current = current.upper;
              } while (current);
            }
          }
        }
        if (this.type === 'global') {
          implicit = [];
          for (i = 0, iz = this.left.length; i < iz; ++i) {
            ref = this.left[i];
            if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
              implicit.push(ref.__maybeImplicitGlobal);
            }
          }
          for (i = 0, iz = implicit.length; i < iz; ++i) {
            node = implicit[i];
            this.__defineImplicit(node.left, {
              type: Variable.ImplicitGlobalVariable,
              name: node.left,
              node: node
            });
          }
        }
        this.left = null;
        currentScope = this.upper;
      };
      Scope.prototype.__resolve = function __resolve(ref) {
        var variable, name;
        name = ref.identifier.name;
        if (this.set.has(name)) {
          variable = this.set.get(name);
          variable.references.push(ref);
          variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
          if (ref.tainted) {
            variable.tainted = true;
            this.taints.set(variable.name, true);
          }
          ref.resolved = variable;
          return true;
        }
        return false;
      };
      Scope.prototype.__delegateToUpperScope = function __delegateToUpperScope(ref) {
        if (this.upper) {
          this.upper.left.push(ref);
        }
        this.through.push(ref);
      };
      Scope.prototype.__defineImplicit = function __defineImplicit(node, info) {
        var name, variable;
        if (node && node.type === Syntax.Identifier) {
          name = node.name;
          if (!this.implicit.set.has(name)) {
            variable = new Variable(name, this);
            variable.identifiers.push(node);
            variable.defs.push(info);
            this.implicit.set.set(name, variable);
            this.implicit.variables.push(variable);
          } else {
            variable = this.implicit.set.get(name);
            variable.identifiers.push(node);
            variable.defs.push(info);
          }
        }
      };
      Scope.prototype.__define = function __define(node, info) {
        var name, variable;
        if (node && node.type === Syntax.Identifier) {
          name = node.name;
          if (!this.set.has(name)) {
            variable = new Variable(name, this);
            variable.identifiers.push(node);
            variable.defs.push(info);
            this.set.set(name, variable);
            this.variables.push(variable);
          } else {
            variable = this.set.get(name);
            variable.identifiers.push(node);
            variable.defs.push(info);
          }
        }
      };
      Scope.prototype.__referencing = function __referencing(node, assign, writeExpr, maybeImplicitGlobal) {
        var ref;
        if (node && node.type === Syntax.Identifier) {
          ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal);
          this.references.push(ref);
          this.left.push(ref);
        }
      };
      Scope.prototype.__detectEval = function __detectEval() {
        var current;
        current = this;
        this.directCallToEvalScope = true;
        do {
          current.dynamic = true;
          current = current.upper;
        } while (current);
      };
      Scope.prototype.__detectThis = function __detectThis() {
        this.thisFound = true;
      };
      Scope.prototype.__isClosed = function isClosed() {
        return this.left === null;
      };
      Scope.prototype.resolve = function resolve(ident) {
        var ref, i, iz;
        assert(this.__isClosed(), 'scope should be closed');
        assert(ident.type === Syntax.Identifier, 'target should be identifier');
        for (i = 0, iz = this.references.length; i < iz; ++i) {
          ref = this.references[i];
          if (ref.identifier === ident) {
            return ref;
          }
        }
        return null;
      };
      Scope.prototype.isStatic = function isStatic() {
        return !this.dynamic;
      };
      Scope.prototype.isArgumentsMaterialized = function isArgumentsMaterialized() {
        var variable;
        if (this.type !== 'function') {
          return true;
        }
        if (!this.isStatic()) {
          return true;
        }
        variable = this.set.get('arguments');
        assert(variable, 'always have arguments variable');
        return variable.tainted || variable.references.length !== 0;
      };
      Scope.prototype.isThisMaterialized = function isThisMaterialized() {
        if (this.type !== 'function') {
          return true;
        }
        if (!this.isStatic()) {
          return true;
        }
        return this.thisFound;
      };
      Scope.mangledName = '__$escope$__';
      Scope.prototype.attach = function attach() {
        if (!this.functionExpressionScope) {
          this.block[Scope.mangledName] = this;
        }
      };
      Scope.prototype.detach = function detach() {
        if (!this.functionExpressionScope) {
          delete this.block[Scope.mangledName];
        }
      };
      Scope.prototype.isUsedName = function (name) {
        if (this.set.has(name)) {
          return true;
        }
        for (var i = 0, iz = this.through.length; i < iz; ++i) {
          if (this.through[i].identifier.name === name) {
            return true;
          }
        }
        return false;
      };
      function ScopeManager(scopes) {
        this.scopes = scopes;
        this.attached = false;
      }
      ScopeManager.prototype.__get = function __get(node) {
        var i, iz, scope;
        if (this.attached) {
          return node[Scope.mangledName] || null;
        }
        if (Scope.isScopeRequired(node)) {
          for (i = 0, iz = this.scopes.length; i < iz; ++i) {
            scope = this.scopes[i];
            if (!scope.functionExpressionScope) {
              if (scope.block === node) {
                return scope;
              }
            }
          }
        }
        return null;
      };
      ScopeManager.prototype.acquire = function acquire(node) {
        return this.__get(node);
      };
      ScopeManager.prototype.release = function release(node) {
        var scope = this.__get(node);
        if (scope) {
          scope = scope.upper;
          while (scope) {
            if (!scope.functionExpressionScope) {
              return scope;
            }
            scope = scope.upper;
          }
        }
        return null;
      };
      ScopeManager.prototype.attach = function attach() {
        var i, iz;
        for (i = 0, iz = this.scopes.length; i < iz; ++i) {
          this.scopes[i].attach();
        }
        this.attached = true;
      };
      ScopeManager.prototype.detach = function detach() {
        var i, iz;
        for (i = 0, iz = this.scopes.length; i < iz; ++i) {
          this.scopes[i].detach();
        }
        this.attached = false;
      };
      Scope.isScopeRequired = function isScopeRequired(node) {
        return Scope.isVariableScopeRequired(node) || node.type === Syntax.WithStatement || node.type === Syntax.CatchClause;
      };
      Scope.isVariableScopeRequired = function isVariableScopeRequired(node) {
        return node.type === Syntax.Program || node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration;
      };
      function analyze(tree, providedOptions) {
        var resultScopes;
        options = updateDeeply(defaultOptions(), providedOptions);
        resultScopes = scopes = [];
        currentScope = null;
        globalScope = null;
        estraverse.traverse(tree, {
          enter: function enter(node) {
            var i, iz, decl;
            if (Scope.isScopeRequired(node)) {
              new Scope(node, {});
            }
            switch (node.type) {
            case Syntax.AssignmentExpression:
              if (node.operator === '=') {
                currentScope.__referencing(node.left, Reference.WRITE, node.right, !currentScope.isStrict && node.left.name != null && node);
              } else {
                currentScope.__referencing(node.left, Reference.RW, node.right);
              }
              currentScope.__referencing(node.right);
              break;
            case Syntax.ArrayExpression:
              for (i = 0, iz = node.elements.length; i < iz; ++i) {
                currentScope.__referencing(node.elements[i]);
              }
              break;
            case Syntax.BlockStatement:
              break;
            case Syntax.BinaryExpression:
              currentScope.__referencing(node.left);
              currentScope.__referencing(node.right);
              break;
            case Syntax.BreakStatement:
              break;
            case Syntax.CallExpression:
              currentScope.__referencing(node.callee);
              for (i = 0, iz = node['arguments'].length; i < iz; ++i) {
                currentScope.__referencing(node['arguments'][i]);
              }
              if (!options.ignoreEval && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {
                currentScope.variableScope.__detectEval();
              }
              break;
            case Syntax.CatchClause:
              currentScope.__define(node.param, {
                type: Variable.CatchClause,
                name: node.param,
                node: node
              });
              break;
            case Syntax.ConditionalExpression:
              currentScope.__referencing(node.test);
              currentScope.__referencing(node.consequent);
              currentScope.__referencing(node.alternate);
              break;
            case Syntax.ContinueStatement:
              break;
            case Syntax.DirectiveStatement:
              break;
            case Syntax.DoWhileStatement:
              currentScope.__referencing(node.test);
              break;
            case Syntax.DebuggerStatement:
              break;
            case Syntax.EmptyStatement:
              break;
            case Syntax.ExpressionStatement:
              currentScope.__referencing(node.expression);
              break;
            case Syntax.ForStatement:
              currentScope.__referencing(node.init);
              currentScope.__referencing(node.test);
              currentScope.__referencing(node.update);
              break;
            case Syntax.ForInStatement:
              if (node.left.type === Syntax.VariableDeclaration) {
                currentScope.__referencing(node.left.declarations[0].id, Reference.WRITE, null, false);
              } else {
                currentScope.__referencing(node.left, Reference.WRITE, null, !currentScope.isStrict && node.left.name != null && node);
              }
              currentScope.__referencing(node.right);
              break;
            case Syntax.FunctionDeclaration:
              currentScope.upper.__define(node.id, {
                type: Variable.FunctionName,
                name: node.id,
                node: node
              });
              for (i = 0, iz = node.params.length; i < iz; ++i) {
                currentScope.__define(node.params[i], {
                  type: Variable.Parameter,
                  name: node.params[i],
                  node: node,
                  index: i
                });
              }
              break;
            case Syntax.FunctionExpression:
              for (i = 0, iz = node.params.length; i < iz; ++i) {
                currentScope.__define(node.params[i], {
                  type: Variable.Parameter,
                  name: node.params[i],
                  node: node,
                  index: i
                });
              }
              break;
            case Syntax.Identifier:
              break;
            case Syntax.IfStatement:
              currentScope.__referencing(node.test);
              break;
            case Syntax.Literal:
              break;
            case Syntax.LabeledStatement:
              break;
            case Syntax.LogicalExpression:
              currentScope.__referencing(node.left);
              currentScope.__referencing(node.right);
              break;
            case Syntax.MemberExpression:
              currentScope.__referencing(node.object);
              if (node.computed) {
                currentScope.__referencing(node.property);
              }
              break;
            case Syntax.NewExpression:
              currentScope.__referencing(node.callee);
              for (i = 0, iz = node['arguments'].length; i < iz; ++i) {
                currentScope.__referencing(node['arguments'][i]);
              }
              break;
            case Syntax.ObjectExpression:
              for (i = 0; i < node.properties.length; i++) {
                if (node.properties[i].kind === 'init') {
                  currentScope.__referencing(node.properties[i].value);
                }
              }
              break;
            case Syntax.Program:
              break;
            case Syntax.Property:
              break;
            case Syntax.ReturnStatement:
              currentScope.__referencing(node.argument);
              break;
            case Syntax.SequenceExpression:
              for (i = 0, iz = node.expressions.length; i < iz; ++i) {
                currentScope.__referencing(node.expressions[i]);
              }
              break;
            case Syntax.SwitchStatement:
              currentScope.__referencing(node.discriminant);
              break;
            case Syntax.SwitchCase:
              currentScope.__referencing(node.test);
              break;
            case Syntax.ThisExpression:
              currentScope.variableScope.__detectThis();
              break;
            case Syntax.ThrowStatement:
              currentScope.__referencing(node.argument);
              break;
            case Syntax.TryStatement:
              break;
            case Syntax.UnaryExpression:
              currentScope.__referencing(node.argument);
              break;
            case Syntax.UpdateExpression:
              currentScope.__referencing(node.argument, Reference.RW, null);
              break;
            case Syntax.VariableDeclaration:
              for (i = 0, iz = node.declarations.length; i < iz; ++i) {
                decl = node.declarations[i];
                currentScope.variableScope.__define(decl.id, {
                  type: Variable.Variable,
                  name: decl.id,
                  node: decl,
                  index: i,
                  parent: node
                });
                if (decl.init) {
                  currentScope.__referencing(decl.id, Reference.WRITE, decl.init, false);
                  currentScope.__referencing(decl.init);
                }
              }
              break;
            case Syntax.VariableDeclarator:
              break;
            case Syntax.WhileStatement:
              currentScope.__referencing(node.test);
              break;
            case Syntax.WithStatement:
              currentScope.upper.__referencing(node.object);
              break;
            }
          },
          leave: function leave(node) {
            while (currentScope && node === currentScope.block) {
              currentScope.__close();
            }
          }
        });
        assert(currentScope === null);
        globalScope = null;
        scopes = null;
        options = null;
        return new ScopeManager(resultScopes);
      }
      exports.version = '1.0.3';
      exports.Reference = Reference;
      exports.Variable = Variable;
      exports.Scope = Scope;
      exports.ScopeManager = ScopeManager;
      exports.analyze = analyze;
    }, this));
  });
  require.define('/escope/node_modules/estraverse/estraverse.js', function (module, exports, __dirname, __filename) {
    (function clone(exports) {
      'use strict';
      var Syntax, isArray, VisitorOption, VisitorKeys, objectCreate, objectKeys, BREAK, SKIP, REMOVE;
      function ignoreJSHintError() {
      }
      isArray = Array.isArray;
      if (!isArray) {
        isArray = function isArray(array) {
          return Object.prototype.toString.call(array) === '[object Array]';
        };
      }
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === 'object' && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
      ignoreJSHintError(shallowCopy);
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      function lowerBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            i = current + 1;
            len -= diff + 1;
          } else {
            len = diff;
          }
        }
        return i;
      }
      ignoreJSHintError(lowerBound);
      objectCreate = Object.create || function () {
        function F() {
        }
        return function (o) {
          F.prototype = o;
          return new F;
        };
      }();
      objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
          keys.push(key);
        }
        return keys;
      };
      function extend(to, from) {
        var keys = objectKeys(from), key, i, len;
        for (i = 0, len = keys.length; i < len; i += 1) {
          key = keys[i];
          to[key] = from[key];
        }
        return to;
      }
      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
      };
      VisitorKeys = {
        AssignmentExpression: [
          'left',
          'right'
        ],
        AssignmentPattern: [
          'left',
          'right'
        ],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: [
          'params',
          'defaults',
          'rest',
          'body'
        ],
        AwaitExpression: ['argument'],
        BlockStatement: ['body'],
        BinaryExpression: [
          'left',
          'right'
        ],
        BreakStatement: ['label'],
        CallExpression: [
          'callee',
          'arguments'
        ],
        CatchClause: [
          'param',
          'body'
        ],
        ClassBody: ['body'],
        ClassDeclaration: [
          'id',
          'superClass',
          'body'
        ],
        ClassExpression: [
          'id',
          'superClass',
          'body'
        ],
        ComprehensionBlock: [
          'left',
          'right'
        ],
        ComprehensionExpression: [
          'blocks',
          'filter',
          'body'
        ],
        ConditionalExpression: [
          'test',
          'consequent',
          'alternate'
        ],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: [
          'body',
          'test'
        ],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: [
          'declaration',
          'specifiers',
          'source'
        ],
        ExportSpecifier: [
          'exported',
          'local'
        ],
        ExpressionStatement: ['expression'],
        ForStatement: [
          'init',
          'test',
          'update',
          'body'
        ],
        ForInStatement: [
          'left',
          'right',
          'body'
        ],
        ForOfStatement: [
          'left',
          'right',
          'body'
        ],
        FunctionDeclaration: [
          'id',
          'params',
          'defaults',
          'rest',
          'body'
        ],
        FunctionExpression: [
          'id',
          'params',
          'defaults',
          'rest',
          'body'
        ],
        GeneratorExpression: [
          'blocks',
          'filter',
          'body'
        ],
        Identifier: [],
        IfStatement: [
          'test',
          'consequent',
          'alternate'
        ],
        ImportDeclaration: [
          'specifiers',
          'source'
        ],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: [
          'imported',
          'local'
        ],
        Literal: [],
        LabeledStatement: [
          'label',
          'body'
        ],
        LogicalExpression: [
          'left',
          'right'
        ],
        MemberExpression: [
          'object',
          'property'
        ],
        MethodDefinition: [
          'key',
          'value'
        ],
        ModuleSpecifier: [],
        NewExpression: [
          'callee',
          'arguments'
        ],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: [
          'key',
          'value'
        ],
        RestElement: ['argument'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        SwitchStatement: [
          'discriminant',
          'cases'
        ],
        SwitchCase: [
          'test',
          'consequent'
        ],
        TaggedTemplateExpression: [
          'tag',
          'quasi'
        ],
        TemplateElement: [],
        TemplateLiteral: [
          'quasis',
          'expressions'
        ],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: [
          'block',
          'handlers',
          'handler',
          'guardedHandlers',
          'finalizer'
        ],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: [
          'id',
          'init'
        ],
        WhileStatement: [
          'test',
          'body'
        ],
        WithStatement: [
          'object',
          'body'
        ],
        YieldExpression: ['argument']
      };
      BREAK = {};
      SKIP = {};
      REMOVE = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
      };
      Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;
        function addToPath(result, path) {
          if (isArray(path)) {
            for (j = 0, jz = path.length; j < jz; ++j) {
              result.push(path[j]);
            }
          } else {
            result.push(path);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = undefined;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function () {
        this.notify(SKIP);
      };
      Controller.prototype['break'] = function () {
        this.notify(BREAK);
      };
      Controller.prototype.remove = function () {
        this.notify(REMOVE);
      };
      Controller.prototype.__initialize = function (root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = visitor.fallback === 'iteration';
        this.__keys = VisitorKeys;
        if (visitor.keys) {
          this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
      };
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
      }
      Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = element.wrap || node.type;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = objectKeys(node);
              } else {
                throw new Error('Unknown node type ' + nodeType + '.');
              }
            }
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                  if (!candidate[current2]) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current])) {
                    element = new Element(candidate[current2], [
                      key,
                      current2
                    ], 'Property', null);
                  } else if (isNode(candidate[current2])) {
                    element = new Element(candidate[current2], [
                      key,
                      current2
                    ], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                worklist.push(new Element(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace(root, visitor) {
        function removeElem(element) {
          var i, key, nextElem, parent;
          if (element.ref.remove()) {
            key = element.ref.key;
            parent = element.ref.parent;
            i = worklist.length;
            while (i--) {
              nextElem = worklist[i];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = { root: root };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
              element.ref.replace(target);
            }
            if (this.__state === REMOVE || target === REMOVE) {
              removeElem(element);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = element.wrap || node.type;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = objectKeys(node);
            } else {
              throw new Error('Unknown node type ' + nodeType + '.');
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], 'Property', new Reference(candidate, current2));
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], null, new Reference(candidate, current2));
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller;
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller;
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [
          comment.range[0],
          comment.range[1]
        ];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error('attachComments needs range information');
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [
                0,
                tree.range[0]
              ];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (comment.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (node.range[1] < comment.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports.version = require('/escope/node_modules/estraverse/package.json', module).version;
      exports.Syntax = Syntax;
      exports.traverse = traverse;
      exports.replace = replace;
      exports.attachComments = attachComments;
      exports.VisitorKeys = VisitorKeys;
      exports.VisitorOption = VisitorOption;
      exports.Controller = Controller;
      exports.cloneEnvironment = function () {
        return clone({});
      };
      return exports;
    }(exports));
  });
  require.define('/escope/node_modules/estraverse/package.json', function (module, exports, __dirname, __filename) {
    module.exports = {
      '_from': 'estraverse@^2.0.0',
      '_id': 'estraverse@2.0.0',
      '_inBundle': false,
      '_integrity': 'sha1-WuRpYyQ2ACBmdMyySgnhZnT83KE=',
      '_location': '/escope/estraverse',
      '_phantomChildren': {},
      '_requested': {
        'type': 'range',
        'registry': true,
        'raw': 'estraverse@^2.0.0',
        'name': 'estraverse',
        'escapedName': 'estraverse',
        'rawSpec': '^2.0.0',
        'saveSpec': null,
        'fetchSpec': '^2.0.0'
      },
      '_requiredBy': ['/escope'],
      '_resolved': 'https://registry.npm.taobao.org/estraverse/download/estraverse-2.0.0.tgz?cache=0&sync_timestamp=1596642998635&other_urls=https%3A%2F%2Fregistry.npm.taobao.org%2Festraverse%2Fdownload%2Festraverse-2.0.0.tgz',
      '_shasum': '5ae46963243600206674ccb24a09e16674fcdca1',
      '_spec': 'estraverse@^2.0.0',
      '_where': 'D:\\work\\efront\\node_modules\\escope',
      'bugs': { 'url': 'https://github.com/estools/estraverse/issues' },
      'bundleDependencies': false,
      'deprecated': false,
      'description': 'ECMAScript JS AST traversal functions',
      'devDependencies': {
        'chai': '^2.1.1',
        'coffee-script': '^1.8.0',
        'espree': '^1.11.0',
        'gulp': '^3.8.10',
        'gulp-bump': '^0.2.2',
        'gulp-filter': '^2.0.0',
        'gulp-git': '^1.0.1',
        'gulp-tag-version': '^1.2.1',
        'jshint': '^2.5.6',
        'mocha': '^2.1.0'
      },
      'engines': { 'node': '>=0.10.0' },
      'homepage': 'https://github.com/estools/estraverse',
      'licenses': [{
          'type': 'BSD',
          'url': 'http://github.com/estools/estraverse/raw/master/LICENSE.BSD'
        }],
      'main': 'estraverse.js',
      'maintainers': [{
          'name': 'Yusuke Suzuki',
          'email': 'utatane.tea@gmail.com',
          'url': 'http://github.com/Constellation'
        }],
      'name': 'estraverse',
      'repository': {
        'type': 'git',
        'url': 'git+ssh://git@github.com/estools/estraverse.git'
      },
      'scripts': {
        'lint': 'jshint estraverse.js',
        'test': 'npm run-script lint && npm run-script unit-test',
        'unit-test': 'mocha --compilers coffee:coffee-script/register'
      },
      'version': '2.0.0'
    };
  });
  require.define('/estraverse/estraverse.js', function (module, exports, __dirname, __filename) {
    (function (root, factory) {
      'use strict';
      if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
      } else if (typeof exports !== 'undefined') {
        factory(exports);
      } else {
        factory(root.estraverse = {});
      }
    }(this, function (exports) {
      'use strict';
      var Syntax, isArray, VisitorOption, VisitorKeys, BREAK, SKIP;
      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
      };
      function ignoreJSHintError() {
      }
      isArray = Array.isArray;
      if (!isArray) {
        isArray = function isArray(array) {
          return Object.prototype.toString.call(array) === '[object Array]';
        };
      }
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === 'object' && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
      ignoreJSHintError(shallowCopy);
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      function lowerBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            i = current + 1;
            len -= diff + 1;
          } else {
            len = diff;
          }
        }
        return i;
      }
      ignoreJSHintError(lowerBound);
      VisitorKeys = {
        AssignmentExpression: [
          'left',
          'right'
        ],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: [
          'params',
          'defaults',
          'rest',
          'body'
        ],
        BlockStatement: ['body'],
        BinaryExpression: [
          'left',
          'right'
        ],
        BreakStatement: ['label'],
        CallExpression: [
          'callee',
          'arguments'
        ],
        CatchClause: [
          'param',
          'body'
        ],
        ClassBody: ['body'],
        ClassDeclaration: [
          'id',
          'body',
          'superClass'
        ],
        ClassExpression: [
          'id',
          'body',
          'superClass'
        ],
        ConditionalExpression: [
          'test',
          'consequent',
          'alternate'
        ],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: [
          'body',
          'test'
        ],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForStatement: [
          'init',
          'test',
          'update',
          'body'
        ],
        ForInStatement: [
          'left',
          'right',
          'body'
        ],
        ForOfStatement: [
          'left',
          'right',
          'body'
        ],
        FunctionDeclaration: [
          'id',
          'params',
          'defaults',
          'rest',
          'body'
        ],
        FunctionExpression: [
          'id',
          'params',
          'defaults',
          'rest',
          'body'
        ],
        Identifier: [],
        IfStatement: [
          'test',
          'consequent',
          'alternate'
        ],
        Literal: [],
        LabeledStatement: [
          'label',
          'body'
        ],
        LogicalExpression: [
          'left',
          'right'
        ],
        MemberExpression: [
          'object',
          'property'
        ],
        MethodDefinition: [
          'key',
          'value'
        ],
        NewExpression: [
          'callee',
          'arguments'
        ],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: [
          'key',
          'value'
        ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchStatement: [
          'discriminant',
          'cases'
        ],
        SwitchCase: [
          'test',
          'consequent'
        ],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: [
          'block',
          'handlers',
          'handler',
          'guardedHandlers',
          'finalizer'
        ],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: [
          'id',
          'init'
        ],
        WhileStatement: [
          'test',
          'body'
        ],
        WithStatement: [
          'object',
          'body'
        ],
        YieldExpression: ['argument']
      };
      BREAK = {};
      SKIP = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
      };
      function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;
        function addToPath(result, path) {
          if (isArray(path)) {
            for (j = 0, jz = path.length; j < jz; ++j) {
              result.push(path[j]);
            }
          } else {
            result.push(path);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = undefined;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function () {
        this.notify(SKIP);
      };
      Controller.prototype['break'] = function () {
        this.notify(BREAK);
      };
      Controller.prototype.__initialize = function (root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
      };
      Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = element.wrap || node.type;
            candidates = VisitorKeys[nodeType];
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (!isArray(candidate)) {
                worklist.push(new Element(candidate, key, null, null));
                continue;
              }
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if ((nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === candidates[current]) {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], 'Property', null);
                } else {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], null, null);
                }
                worklist.push(element);
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = { root: root };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== undefined && target !== BREAK && target !== SKIP) {
              element.ref.replace(target);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== undefined && target !== BREAK && target !== SKIP) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = element.wrap || node.type;
          candidates = VisitorKeys[nodeType];
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (!isArray(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
              continue;
            }
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                element = new Element(candidate[current2], [
                  key,
                  current2
                ], 'Property', new Reference(candidate, current2));
              } else {
                element = new Element(candidate[current2], [
                  key,
                  current2
                ], null, new Reference(candidate, current2));
              }
              worklist.push(element);
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller;
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller;
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [
          comment.range[0],
          comment.range[1]
        ];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error('attachComments needs range information');
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [
                0,
                tree.range[0]
              ];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (comment.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (node.range[1] < comment.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports.version = '1.5.1-dev';
      exports.Syntax = Syntax;
      exports.traverse = traverse;
      exports.replace = replace;
      exports.attachComments = attachComments;
      exports.VisitorKeys = VisitorKeys;
      exports.VisitorOption = VisitorOption;
      exports.Controller = Controller;
    }));
  });
  require.define('/esmangle/lib/pass.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var query, Registry, pass, post, common;
      common = require('/esmangle/lib/common.js', module);
      query = require('/esmangle/lib/query.js', module);
      Registry = {};
      Registry.__direct = {};
      function initialize(kind, passes) {
        var i, iz, pass;
        Registry[kind] = {};
        for (i = 0, iz = passes.length; i < iz; ++i) {
          pass = passes[i];
          common.assert(Registry[kind][pass.passName] == null, "don't create duplicate pass names");
          Registry[kind][pass.passName] = pass;
        }
        common.assert(Registry.__direct[pass.passName] == null, "don't create duplicate pass names");
        Registry.__direct[pass.passName] = pass;
      }
      pass = [
        require('/esmangle/lib/pass/hoist-variable-to-arguments.js', module),
        require('/esmangle/lib/pass/transform-dynamic-to-static-property-access.js', module),
        require('/esmangle/lib/pass/transform-dynamic-to-static-property-definition.js', module),
        require('/esmangle/lib/pass/transform-immediate-function-call.js', module),
        require('/esmangle/lib/pass/transform-logical-association.js', module),
        require('/esmangle/lib/pass/reordering-function-declarations.js', module),
        require('/esmangle/lib/pass/remove-unused-label.js', module),
        require('/esmangle/lib/pass/remove-empty-statement.js', module),
        require('/esmangle/lib/pass/remove-wasted-blocks.js', module),
        require('/esmangle/lib/pass/transform-to-compound-assignment.js', module),
        require('/esmangle/lib/pass/transform-to-sequence-expression.js', module),
        require('/esmangle/lib/pass/transform-branch-to-expression.js', module),
        require('/esmangle/lib/pass/transform-typeof-undefined.js', module),
        require('/esmangle/lib/pass/reduce-sequence-expression.js', module),
        require('/esmangle/lib/pass/reduce-branch-jump.js', module),
        require('/esmangle/lib/pass/reduce-multiple-if-statements.js', module),
        require('/esmangle/lib/pass/dead-code-elimination.js', module),
        require('/esmangle/lib/pass/remove-side-effect-free-expressions.js', module),
        require('/esmangle/lib/pass/remove-context-sensitive-expressions.js', module),
        require('/esmangle/lib/pass/tree-based-constant-folding.js', module),
        require('/esmangle/lib/pass/concatenate-variable-definition.js', module),
        require('/esmangle/lib/pass/drop-variable-definition.js', module),
        require('/esmangle/lib/pass/remove-unreachable-branch.js', module),
        require('/esmangle/lib/pass/eliminate-duplicate-function-declarations.js', module)
      ];
      post = [
        require('/esmangle/lib/post/transform-static-to-dynamic-property-access.js', module),
        require('/esmangle/lib/post/transform-infinity.js', module),
        require('/esmangle/lib/post/rewrite-boolean.js', module),
        require('/esmangle/lib/post/rewrite-conditional-expression.js', module),
        require('/esmangle/lib/post/omit-parens-in-void-context-iife.js', module)
      ];
      initialize('pass', pass);
      initialize('post', post);
      function passRequire(name) {
        if (common.Object.has(Registry.__direct, name)) {
          return Registry.__direct[name];
        }
        return query.get(Registry, name.split('/'));
      }
      exports.require = passRequire;
      exports.Registry = Registry;
      exports.__defaultPipeline = [
        pass,
        {
          once: true,
          pass: post
        }
      ];
    }());
  });
  require.define('/esmangle/lib/post/omit-parens-in-void-context-iife.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'omit-parens-in-void-context-iife';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function isIIFE(node) {
        var callee;
        if (node.type !== Syntax.CallExpression) {
          return false;
        }
        callee = node.callee;
        return callee.type === Syntax.FunctionExpression;
      }
      function main(tree, options) {
        var result, stackCount, preserveCompletionValue;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        preserveCompletionValue = options.get('preserveCompletionValue', { pathName: Name });
        modified = false;
        result = common.replace(result, {
          enter: function enter(node, parent) {
            var ancestors, target;
            if (!isIIFE(node)) {
              return;
            }
            target = parent;
            if (target.type === Syntax.ExpressionStatement) {
              ancestors = this.parents();
              ancestors.pop();
              if (preserveCompletionValue && common.mayBeCompletionValue(target, ancestors)) {
                return;
              }
            } else if (target.type === Syntax.SequenceExpression && target.expressions.length >= 2 && target.expressions[0] === node) {
              ancestors = this.parents();
              ancestors.pop();
              target = ancestors.pop();
              if (target.type !== Syntax.ExpressionStatement) {
                return;
              }
            } else {
              return;
            }
            modified = true;
            return {
              type: Syntax.UnaryExpression,
              operator: '!',
              argument: node
            };
          },
          leave: function leave(node) {
            if (node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration) {
              --stackCount;
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      main.passName = Name;
      module.exports = main;
    }());
  });
  require.define('/esmangle/lib/post/rewrite-conditional-expression.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'rewrite-conditional-expression';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function rewrite(node) {
        var test, consequent, alternate;
        test = node.test;
        consequent = node.consequent;
        alternate = node.alternate;
        if (test.type === Syntax.UnaryExpression && test.operator === '!') {
          modified = true;
          node.consequent = alternate;
          node.alternate = consequent;
          node.test = test.argument;
        }
      }
      function rewriteConditionalExpression(tree, options) {
        var result;
        modified = false;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        common.traverse(result, {
          enter: function enter(node) {
            if (node.type === Syntax.ConditionalExpression) {
              rewrite(node);
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      rewriteConditionalExpression.passName = Name;
      module.exports = rewriteConditionalExpression;
    }());
  });
  require.define('/esmangle/lib/post/rewrite-boolean.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'rewrite-boolean';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function isBooleanLiteral(node) {
        return node.type === Syntax.Literal && typeof node.value === 'boolean';
      }
      function rewrite(node) {
        if (isBooleanLiteral(node)) {
          modified = true;
          return common.moveLocation(node, {
            type: Syntax.UnaryExpression,
            operator: '!',
            argument: common.moveLocation(node, {
              type: Syntax.Literal,
              value: +!node.value
            })
          });
        }
        if (node.type === Syntax.BinaryExpression && node.operator === '==' || node.operator === '!=') {
          if (isBooleanLiteral(node.left)) {
            modified = true;
            node.left = common.moveLocation(node.left, {
              type: Syntax.Literal,
              value: +node.left.value
            });
            return node;
          }
          if (isBooleanLiteral(node.right)) {
            modified = true;
            node.right = common.moveLocation(node.right, {
              type: Syntax.Literal,
              value: +node.right.value
            });
            return node;
          }
        }
        return node;
      }
      function rewriteBoolean(tree, options) {
        var result;
        modified = false;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        result = common.replace(result, { enter: rewrite });
        return {
          result: result,
          modified: modified
        };
      }
      rewriteBoolean.passName = Name;
      module.exports = rewriteBoolean;
    }());
  });
  require.define('/esmangle/lib/post/transform-infinity.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common;
      Name = 'transform-infinity';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function transformInfinity(tree, options) {
        var result, modified;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        result = common.replace(result, {
          enter: function enter(node) {
            if (node.type === Syntax.Literal && typeof node.value === 'number') {
              if (node.value === Infinity) {
                modified = true;
                return common.moveLocation(node, {
                  type: Syntax.BinaryExpression,
                  operator: '/',
                  left: {
                    type: Syntax.Literal,
                    value: 1
                  },
                  right: {
                    type: Syntax.Literal,
                    value: 0
                  }
                });
              }
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      transformInfinity.passName = Name;
      module.exports = transformInfinity;
    }());
  });
  require.define('/esmangle/lib/post/transform-static-to-dynamic-property-access.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common;
      Name = 'transform-static-to-dynamic-property-access';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function transformStaticToDynamicPropertyAccess(tree, options) {
        var result, modified;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        common.traverse(result, {
          enter: function enter(node) {
            var property;
            if (node.type !== Syntax.MemberExpression || node.computed || node.property.type !== Syntax.Identifier) {
              return;
            }
            property = node.property;
            switch (property.name) {
            case 'undefined':
              modified = true;
              node.computed = true;
              node.property = common.moveLocation(property, {
                type: Syntax.UnaryExpression,
                operator: 'void',
                argument: {
                  type: Syntax.Literal,
                  value: 0
                }
              });
              break;
            case 'true':
            case 'false':
              modified = true;
              node.computed = true;
              node.property = common.moveLocation(property, {
                type: Syntax.Literal,
                value: property.name === 'true'
              });
              break;
            case 'Infinity':
              modified = true;
              node.computed = true;
              node.property = common.moveLocation(property, {
                type: Syntax.BinaryExpression,
                operator: '/',
                left: {
                  type: Syntax.Literal,
                  value: 1
                },
                right: {
                  type: Syntax.Literal,
                  value: 0
                }
              });
              break;
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      transformStaticToDynamicPropertyAccess.passName = Name;
      module.exports = transformStaticToDynamicPropertyAccess;
    }());
  });
  require.define('/esmangle/lib/pass/eliminate-duplicate-function-declarations.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, Map, common, modified;
      Name = 'eliminate-duplicate-function-declarations';
      common = require('/esmangle/lib/common.js', module);
      Map = require('/esmangle/lib/map.js', module);
      Syntax = common.Syntax;
      function unique(map, root) {
        return common.replace(root, {
          enter: function (node) {
            var name, info;
            if (node.type === Syntax.FunctionDeclaration) {
              name = node.id.name;
              info = map.get(name);
              --info.count;
              if (info.count !== 0) {
                modified = true;
                return common.moveLocation(node, { type: Syntax.EmptyStatement });
              }
            }
            if (node !== root && node.type === Syntax.BlockStatement) {
              return this.skip();
            }
          }
        });
      }
      function uniqueInGlobal(map, root) {
        return common.replace(root, {
          enter: function (node) {
            var name, info, first;
            if (node.type === Syntax.FunctionDeclaration) {
              name = node.id.name;
              info = map.get(name);
              first = info.count === info.declarations.length;
              --info.count;
              if (info.declarations.length > 1) {
                if (first) {
                  modified = true;
                  return common.Array.last(info.declarations);
                } else {
                  modified = true;
                  return common.moveLocation(node, { type: Syntax.EmptyStatement });
                }
              }
            }
            if (node !== root && node.type === Syntax.BlockStatement) {
              return this.skip();
            }
          }
        });
      }
      function main(tree, options) {
        var result, stack, functionDepth, globalBlockFound;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        functionDepth = 0;
        globalBlockFound = false;
        stack = [new Map];
        result = common.replace(result, {
          enter: function enter(node) {
            var map, name, info;
            if (node.type === Syntax.FunctionDeclaration) {
              name = node.id.name;
              map = common.Array.last(stack);
              if (map.has(name)) {
                info = map.get(name);
                info.declarations.push(node);
                ++info.count;
              } else {
                info = {
                  declarations: [node],
                  count: 1
                };
                map.set(name, info);
              }
            }
            if (node.type === Syntax.BlockStatement) {
              stack.push(new Map);
            }
            if (node.type === Syntax.FunctionDeclaration || node.type === Syntax.FunctionExpression) {
              ++functionDepth;
            }
          },
          leave: function leave(node) {
            var map, ret;
            if (node.type === Syntax.BlockStatement) {
              map = stack.pop();
              if (functionDepth === 0) {
                if (map.keys().length !== 0) {
                  globalBlockFound = true;
                }
              } else {
                ret = unique(map, node);
              }
            }
            if (node.type === Syntax.FunctionDeclaration || node.type === Syntax.FunctionExpression) {
              --functionDepth;
            }
            return ret;
          }
        });
        common.assert(stack.length === 1, 'global map remains');
        if (!globalBlockFound) {
          result = uniqueInGlobal(stack[0], result);
        }
        return {
          result: result,
          modified: modified
        };
      }
      main.passName = Name;
      module.exports = main;
    }());
  });
  require.define('/esmangle/lib/map.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Map;
      if (typeof global.Map !== 'undefined') {
        Map = global.Map;
      } else {
        Map = function Map() {
          this.__data = {};
        };
        Map.prototype.get = function MapGet(key) {
          key = '$' + key;
          if (this.__data.hasOwnProperty(key)) {
            return this.__data[key];
          }
        };
        Map.prototype.has = function MapHas(key) {
          key = '$' + key;
          return this.__data.hasOwnProperty(key);
        };
        Map.prototype.set = function MapSet(key, val) {
          key = '$' + key;
          this.__data[key] = val;
        };
        Map.prototype['delete'] = function MapDelete(key) {
          key = '$' + key;
          return delete this.__data[key];
        };
        Map.prototype.clear = function MapClear() {
          this.__data = {};
        };
        Map.prototype.forEach = function MapForEach(callback, thisArg) {
          var real, key;
          for (real in this.__data) {
            if (this.__data.hasOwnProperty(real)) {
              key = real.substring(1);
              callback.call(thisArg, this.__data[real], key, this);
            }
          }
        };
        Map.prototype.keys = function MapKeys() {
          var real, result;
          result = [];
          for (real in this.__data) {
            if (this.__data.hasOwnProperty(real)) {
              result.push(real.substring(1));
            }
          }
          return result;
        };
        Map.prototype.values = function MapValues() {
          var real, result;
          result = [];
          for (real in this.__data) {
            if (this.__data.hasOwnProperty(real)) {
              result.push(this.__data[real]);
            }
          }
          return result;
        };
        Map.prototype.items = function MapItems() {
          var real, result;
          result = [];
          for (real in this.__data) {
            if (this.__data.hasOwnProperty(real)) {
              result.push([
                real.substring(1),
                this.__data[real]
              ]);
            }
          }
          return result;
        };
      }
      module.exports = Map;
    }());
  });
  require.define('/esmangle/lib/pass/remove-unreachable-branch.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, escope, evaluator, modified;
      Name = 'remove-unreachable-branch';
      escope = require('/escope/escope.js', module);
      common = require('/esmangle/lib/common.js', module);
      evaluator = require('/esmangle/lib/evaluator.js', module);
      Syntax = common.Syntax;
      function handleIfStatement(func, node) {
        var test, body, decl;
        test = evaluator.booleanCondition(node.test);
        if (!node.alternate) {
          if (typeof test === 'boolean') {
            modified = true;
            body = [];
            if (test) {
              body.push(common.moveLocation(node.test, {
                type: Syntax.ExpressionStatement,
                expression: node.test
              }), node.consequent);
              return {
                type: Syntax.BlockStatement,
                body: body
              };
            } else {
              decl = common.delegateVariableDeclarations(node.consequent, func);
              if (decl) {
                body.push(decl);
              }
              body.push(common.moveLocation(node.test, {
                type: Syntax.ExpressionStatement,
                expression: node.test
              }));
              return {
                type: Syntax.BlockStatement,
                body: body
              };
            }
          }
        } else {
          if (typeof test === 'boolean') {
            modified = true;
            body = [];
            if (test) {
              decl = common.delegateVariableDeclarations(node.alternate, func);
              if (decl) {
                body.push(decl);
              }
              body.push(common.moveLocation(node.test, {
                type: Syntax.ExpressionStatement,
                expression: node.test
              }), node.consequent);
              return {
                type: Syntax.BlockStatement,
                body: body
              };
            } else {
              decl = common.delegateVariableDeclarations(node.consequent, func);
              if (decl) {
                body.push(decl);
              }
              body.push(common.moveLocation(node.test, {
                type: Syntax.ExpressionStatement,
                expression: node.test
              }), node.alternate);
              return {
                type: Syntax.BlockStatement,
                body: body
              };
            }
          }
        }
      }
      function handleLogicalExpression(func, node) {
        var test;
        test = evaluator.booleanCondition(node.left);
        if (typeof test === 'boolean') {
          modified = true;
          if (test) {
            if (node.operator === '&&') {
              return common.moveLocation(node, {
                type: Syntax.SequenceExpression,
                expressions: [
                  node.left,
                  node.right
                ]
              });
            } else {
              return node.left;
            }
          } else {
            if (node.operator === '&&') {
              return node.left;
            } else {
              return common.moveLocation(node, {
                type: Syntax.SequenceExpression,
                expressions: [
                  node.left,
                  node.right
                ]
              });
            }
          }
        }
      }
      function handleConditionalExpression(func, node) {
        var test;
        test = evaluator.booleanCondition(node.test);
        if (typeof test === 'boolean') {
          modified = true;
          if (test) {
            return common.moveLocation(node, {
              type: Syntax.SequenceExpression,
              expressions: [
                node.test,
                node.consequent
              ]
            });
          } else {
            return common.moveLocation(node, {
              type: Syntax.SequenceExpression,
              expressions: [
                node.test,
                node.alternate
              ]
            });
          }
        }
      }
      function removeUnreachableBranch(tree, options) {
        var result, stack;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        stack = [];
        result = common.replace(result, {
          enter: function enter(node) {
            var func;
            if (escope.Scope.isVariableScopeRequired(node)) {
              stack.push(node);
              return;
            }
            func = common.Array.last(stack);
            switch (node.type) {
            case Syntax.IfStatement:
              return handleIfStatement(func, node);
            case Syntax.LogicalExpression:
              return handleLogicalExpression(func, node);
            case Syntax.ConditionalExpression:
              return handleConditionalExpression(func, node);
            }
          },
          leave: function leave(node) {
            if (escope.Scope.isVariableScopeRequired(node)) {
              stack.pop();
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      removeUnreachableBranch.passName = Name;
      module.exports = removeUnreachableBranch;
    }());
  });
  require.define('/esmangle/lib/evaluator.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Syntax, common;
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function isConstant(node, allowRegExp) {
        if (node.type === Syntax.Literal) {
          if (typeof node.value === 'object' && node.value !== null) {
            return allowRegExp;
          }
          return true;
        }
        if (node.type === Syntax.UnaryExpression) {
          if (node.operator === 'void' || node.operator === 'delete' || node.operator === '!') {
            return isConstant(node.argument, true);
          }
          return isConstant(node.argument, false);
        }
        if (node.type === Syntax.BinaryExpression) {
          if (node.operator === 'in' || node.operator === 'instanceof') {
            return false;
          }
          return isConstant(node.left, false) && isConstant(node.right, false);
        }
        if (node.type === Syntax.LogicalExpression) {
          return isConstant(node.left, true) && isConstant(node.right, true);
        }
        return false;
      }
      function getConstant(node) {
        if (node.type === Syntax.Literal) {
          return node.value;
        }
        if (node.type === Syntax.UnaryExpression) {
          return doUnary(node.operator, getConstant(node.argument));
        }
        if (node.type === Syntax.BinaryExpression) {
          return doBinary(node.operator, getConstant(node.left), getConstant(node.right));
        }
        if (node.type === Syntax.LogicalExpression) {
          return doLogical(node.operator, getConstant(node.left), getConstant(node.right));
        }
        common.unreachable();
      }
      function doLogical(operator, left, right) {
        if (operator === '||') {
          return left || right;
        }
        if (operator === '&&') {
          return left && right;
        }
        common.unreachable();
      }
      function doUnary(operator, argument) {
        switch (operator) {
        case '+':
          return +argument;
        case '-':
          return -argument;
        case '~':
          return ~argument;
        case '!':
          return !argument;
        case 'delete':
          return true;
        case 'void':
          return undefined;
        case 'typeof':
          return typeof argument;
        }
        common.unreachable();
      }
      function doBinary(operator, left, right) {
        switch (operator) {
        case '|':
          return left | right;
        case '^':
          return left ^ right;
        case '&':
          return left & right;
        case '==':
          return left == right;
        case '!=':
          return left != right;
        case '===':
          return left === right;
        case '!==':
          return left !== right;
        case '<':
          return left < right;
        case '>':
          return left > right;
        case '<=':
          return left <= right;
        case '>=':
          return left >= right;
        case '<<':
          return left << right;
        case '>>':
          return left >> right;
        case '>>>':
          return left >>> right;
        case '+':
          return left + right;
        case '-':
          return left - right;
        case '*':
          return left * right;
        case '/':
          return left / right;
        case '%':
          return left % right;
        }
        common.unreachable();
      }
      exports.constant = {
        doBinary: doBinary,
        doUnary: doUnary,
        doLogical: doLogical,
        evaluate: getConstant,
        isConstant: isConstant
      };
      function hasSideEffect(expr, scope) {
        function visit(expr) {
          var i, iz, ref;
          switch (expr.type) {
          case Syntax.AssignmentExpression:
            return true;
          case Syntax.ArrayExpression:
            for (i = 0, iz = expr.elements.length; i < iz; ++i) {
              if (expr.elements[i] !== null && visit(expr.elements[i])) {
                return true;
              }
            }
            return false;
          case Syntax.BinaryExpression:
            return !isConstant(expr);
          case Syntax.CallExpression:
            return true;
          case Syntax.ConditionalExpression:
            return visit(expr.test) || visit(expr.consequent) || visit(expr.alternate);
          case Syntax.FunctionExpression:
            return false;
          case Syntax.Identifier:
            ref = scope.resolve(expr);
            if (ref && ref.isStatic()) {
              return false;
            }
            return true;
          case Syntax.Literal:
            return false;
          case Syntax.LogicalExpression:
            return visit(expr.left) || visit(expr.right);
          case Syntax.MemberExpression:
            return true;
          case Syntax.NewExpression:
            return true;
          case Syntax.ObjectExpression:
            for (i = 0, iz = expr.properties.length; i < iz; ++i) {
              if (visit(expr.properties[i])) {
                return true;
              }
            }
            return false;
          case Syntax.Property:
            return visit(expr.value);
          case Syntax.SequenceExpression:
            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
              if (visit(expr.expressions[i])) {
                return true;
              }
            }
            return false;
          case Syntax.ThisExpression:
            return false;
          case Syntax.UnaryExpression:
            if (expr.operator === 'void' || expr.operator === 'delete' || expr.operator === 'typeof' || expr.operator === '!') {
              return visit(expr.argument);
            }
            return !isConstant(expr);
          case Syntax.UpdateExpression:
            return true;
          }
          return true;
        }
        return visit(expr);
      }
      exports.hasSideEffect = hasSideEffect;
      function booleanCondition(expr) {
        var ret;
        switch (expr.type) {
        case Syntax.AssignmentExpression:
          return booleanCondition(expr.right);
        case Syntax.ArrayExpression:
          return true;
        case Syntax.BinaryExpression:
          if (isConstant(expr)) {
            return !!getConstant(expr);
          }
          return null;
        case Syntax.CallExpression:
          return null;
        case Syntax.ConditionalExpression:
          ret = booleanCondition(expr.test);
          if (ret === true) {
            return booleanCondition(expr.consequent);
          }
          if (ret === false) {
            return booleanCondition(expr.alternate);
          }
          ret = booleanCondition(expr.consequent);
          if (ret === booleanCondition(expr.alternate)) {
            return ret;
          }
          return null;
        case Syntax.FunctionExpression:
          return true;
        case Syntax.Identifier:
          return null;
        case Syntax.Literal:
          return !!getConstant(expr);
        case Syntax.LogicalExpression:
          if (expr.operator === '&&') {
            ret = booleanCondition(expr.left);
            if (ret === null) {
              return null;
            }
            if (!ret) {
              return false;
            }
            return booleanCondition(expr.right);
          } else {
            ret = booleanCondition(expr.left);
            if (ret === null) {
              return null;
            }
            if (ret) {
              return true;
            }
            return booleanCondition(expr.right);
          }
          return null;
        case Syntax.MemberExpression:
          return null;
        case Syntax.NewExpression:
          return true;
        case Syntax.ObjectExpression:
          return true;
        case Syntax.Property:
          common.unreachable();
          return null;
        case Syntax.SequenceExpression:
          return booleanCondition(common.Array.last(expr.expressions));
        case Syntax.ThisExpression:
          return null;
        case Syntax.UnaryExpression:
          if (expr.operator === 'void') {
            return false;
          }
          if (expr.operator === 'typeof') {
            return true;
          }
          if (expr.operator === '!') {
            ret = booleanCondition(expr.argument);
            if (ret === null) {
              return null;
            }
            return !ret;
          }
          if (isConstant(expr)) {
            return !!getConstant(expr);
          }
          return null;
        case Syntax.UpdateExpression:
          return null;
        }
        return null;
      }
      exports.booleanCondition = booleanCondition;
    }());
  });
  require.define('/esmangle/lib/pass/drop-variable-definition.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified, escope, evaluator;
      Name = 'drop-variable-definition';
      common = require('/esmangle/lib/common.js', module);
      escope = require('/escope/escope.js', module);
      evaluator = require('/esmangle/lib/evaluator.js', module);
      Syntax = common.Syntax;
      function getCandidates(scope) {
        var i, iz, j, jz, identifiers, slots, v;
        if (!scope.candidates) {
          slots = [];
          identifiers = [];
          for (i = 0, iz = scope.variables.length; i < iz; ++i) {
            v = scope.variables[i];
            for (j = 0, jz = v.identifiers.length; j < jz; ++j) {
              identifiers.push(v.identifiers[j]);
              slots.push(v);
            }
          }
          scope.candidates = {
            slots: slots,
            identifiers: identifiers
          };
        }
        return scope.candidates;
      }
      function isRemovableDefinition(slot) {
        var i, iz, ref, parent;
        if (slot.identifiers.length !== 1) {
          return false;
        }
        if (slot.references.length === 0) {
          return true;
        }
        for (i = 0, iz = slot.references.length; i < iz; ++i) {
          ref = slot.references[i];
          if (ref.isRead()) {
            return false;
          }
          if (ref.isWrite()) {
            if (!ref.writeExpr) {
              return false;
            }
            parent = ref.writeExpr.__$parent$__;
            if (!parent) {
              return false;
            }
            if (parent.type !== Syntax.AssignmentExpression && parent.type !== Syntax.VariableDeclarator) {
              return false;
            }
            if (evaluator.hasSideEffect(ref.writeExpr, ref.from)) {
              return false;
            }
          }
        }
        return true;
      }
      function overrideExpression(from, to) {
        var key;
        for (key in from) {
          delete from[key];
        }
        for (key in to) {
          from[key] = to[key];
        }
        return from;
      }
      function removeDefinition(node, index, slot) {
        var i, iz, ref, parent;
        node.declarations.splice(index, 1);
        for (i = 0, iz = slot.references.length; i < iz; ++i) {
          ref = slot.references[i];
          common.assert(!ref.isRead());
          if (ref.isWrite()) {
            parent = ref.writeExpr.__$parent$__;
            if (parent.type === Syntax.AssignmentExpression) {
              overrideExpression(ref.writeExpr.__$parent$__, ref.writeExpr);
            }
          }
        }
      }
      function attachParent(tree) {
        return common.traverse(tree, {
          enter: function (node, parent) {
            node.__$parent$__ = parent;
          }
        });
      }
      function removeParent(tree) {
        return common.traverse(tree, {
          enter: function (node) {
            delete node.__$parent$__;
            delete node.__$escope$__;
          }
        });
      }
      function dropVariableDefinition(tree, options) {
        var result, manager, scope;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        scope = null;
        manager = escope.analyze(result, { directive: true });
        manager.attach();
        attachParent(result);
        result = common.replace(result, {
          enter: function enter(node, parent) {
            var i, decl, cand, index, slot, ret;
            ret = node;
            if (scope) {
              if (scope.variableScope.isStatic()) {
                cand = getCandidates(scope.variableScope);
                if (node.type === Syntax.VariableDeclaration && node.kind === 'var') {
                  i = node.declarations.length;
                  while (i--) {
                    decl = node.declarations[i];
                    index = cand.identifiers.indexOf(decl.id);
                    if (index !== -1) {
                      slot = cand.slots[index];
                      if (isRemovableDefinition(slot)) {
                        modified = true;
                        removeDefinition(node, i, slot);
                        continue;
                      }
                    }
                  }
                  if (node.declarations.length === 0) {
                    if (parent.type === Syntax.ForStatement) {
                      ret = null;
                    } else {
                      ret = common.moveLocation(node, { type: Syntax.EmptyStatement });
                    }
                  }
                }
                if (node.type === Syntax.FunctionDeclaration) {
                  index = cand.identifiers.indexOf(node.id);
                  if (index !== -1) {
                    slot = cand.slots[index];
                    if (slot.identifiers.length === 1 && slot.references.length === 0) {
                      modified = true;
                      ret = common.moveLocation(node, { type: Syntax.EmptyStatement });
                      return ret;
                    }
                  }
                }
              }
            }
            scope = manager.acquire(node) || scope;
            return ret;
          },
          leave: function leave(node) {
            scope = manager.release(node) || scope;
          }
        });
        manager.detach();
        removeParent(result);
        return {
          result: result,
          modified: modified
        };
      }
      dropVariableDefinition.passName = Name;
      module.exports = dropVariableDefinition;
    }());
  });
  require.define('/esmangle/lib/pass/concatenate-variable-definition.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'concatenate-variable-definition';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function concatenateVariableDefinition(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        common.traverse(result, {
          leave: function leave(node) {
            var i, iz, j, jz, stmt, decl, target, body;
            if (node.type !== Syntax.BlockStatement && node.type !== Syntax.Program) {
              return;
            }
            target = null;
            body = [];
            for (i = 0, iz = node.body.length; i < iz; ++i) {
              stmt = node.body[i];
              if (stmt.type === Syntax.VariableDeclaration && stmt.kind === 'var') {
                if (!target) {
                  target = stmt;
                  body.push(stmt);
                  continue;
                }
                modified = true;
                for (j = 0, jz = stmt.declarations.length; j < jz; ++j) {
                  decl = stmt.declarations[j];
                  target.declarations.push(decl);
                }
              } else {
                target = null;
                body.push(stmt);
              }
            }
            node.body = body;
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      concatenateVariableDefinition.passName = Name;
      module.exports = concatenateVariableDefinition;
    }());
  });
  require.define('/esmangle/lib/pass/tree-based-constant-folding.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, evaluator, modified;
      Name = 'tree-based-constant-folding';
      common = require('/esmangle/lib/common.js', module);
      evaluator = require('/esmangle/lib/evaluator.js', module);
      Syntax = common.Syntax;
      function isModifiedConstant(node) {
        if (common.SpecialNode.isUndefined(node)) {
          return false;
        }
        if (common.SpecialNode.isNegative(node)) {
          return false;
        }
        if (common.SpecialNode.isNaN(node)) {
          return false;
        }
        return evaluator.constant.isConstant(node, false);
      }
      function isFoldableConditional(node) {
        if (node.type !== Syntax.ConditionalExpression) {
          return false;
        }
        return evaluator.constant.isConstant(node.consequent) || evaluator.constant.isConstant(node.alternate);
      }
      function foldConditional(node) {
        var binary, unary, operator, left, right;
        switch (node.type) {
        case Syntax.BinaryExpression:
          if (node.operator === 'in' || node.operator === 'instanceof') {
            return node;
          }
          if (evaluator.constant.isConstant(node.left) && isFoldableConditional(node.right)) {
            modified = true;
            binary = node;
            operator = binary.operator;
            left = evaluator.constant.evaluate(binary.left);
            node = node.right;
            if (evaluator.constant.isConstant(node.consequent)) {
              node.consequent = common.SpecialNode.generateFromValue(evaluator.constant.doBinary(operator, left, evaluator.constant.evaluate(node.consequent)));
            } else {
              binary.right = node.consequent;
              node.consequent = binary;
            }
            if (evaluator.constant.isConstant(node.alternate)) {
              node.alternate = common.SpecialNode.generateFromValue(evaluator.constant.doBinary(operator, left, evaluator.constant.evaluate(node.alternate)));
            } else {
              binary.right = node.alternate;
              node.alternate = binary;
            }
          } else if (evaluator.constant.isConstant(node.right) && isFoldableConditional(node.left)) {
            modified = true;
            binary = node;
            operator = binary.operator;
            right = evaluator.constant.evaluate(binary.right);
            node = node.left;
            if (evaluator.constant.isConstant(node.consequent)) {
              node.consequent = common.SpecialNode.generateFromValue(evaluator.constant.doBinary(operator, evaluator.constant.evaluate(node.consequent), right));
            } else {
              binary.left = node.consequent;
              node.consequent = binary;
            }
            if (evaluator.constant.isConstant(node.alternate)) {
              node.alternate = common.SpecialNode.generateFromValue(evaluator.constant.doBinary(operator, evaluator.constant.evaluate(node.alternate), right));
            } else {
              binary.left = node.alternate;
              node.alternate = binary;
            }
          }
          break;
        case Syntax.LogicalExpression:
          break;
        case Syntax.UnaryExpression:
          if (isFoldableConditional(node.argument)) {
            modified = true;
            unary = node;
            operator = unary.operator;
            node = unary.argument;
            if (evaluator.constant.isConstant(node.consequent)) {
              node.consequent = common.SpecialNode.generateFromValue(evaluator.constant.doUnary(operator, evaluator.constant.evaluate(node.consequent)));
            } else {
              unary.argument = node.consequent;
              node.consequent = unary;
            }
            if (evaluator.constant.isConstant(node.alternate)) {
              node.alternate = common.SpecialNode.generateFromValue(evaluator.constant.doUnary(operator, evaluator.constant.evaluate(node.alternate)));
            } else {
              unary.argument = node.alternate;
              node.alternate = unary;
            }
          }
          break;
        }
        return node;
      }
      function treeBasedConstantFolding(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        result = common.replace(result, {
          leave: function leave(node) {
            var con, alt;
            switch (node.type) {
            case Syntax.BinaryExpression:
            case Syntax.LogicalExpression:
            case Syntax.UnaryExpression:
              if (isModifiedConstant(node)) {
                modified = true;
                return common.moveLocation(node, common.SpecialNode.generateFromValue(evaluator.constant.evaluate(node)));
              }
              return foldConditional(node);
            case Syntax.ConditionalExpression:
              if (evaluator.constant.isConstant(node.consequent) && evaluator.constant.isConstant(node.alternate)) {
                con = evaluator.constant.evaluate(node.consequent);
                alt = evaluator.constant.evaluate(node.alternate);
                if (common.sameValue(con, alt)) {
                  modified = true;
                  return common.moveLocation(node, {
                    type: Syntax.SequenceExpression,
                    expressions: [
                      node.test,
                      common.SpecialNode.generateFromValue(con)
                    ]
                  });
                }
              }
              break;
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      treeBasedConstantFolding.passName = Name;
      module.exports = treeBasedConstantFolding;
    }());
  });
  require.define('/esmangle/lib/pass/remove-context-sensitive-expressions.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, evaluator, escope, modified;
      Name = 'remove-context-sensitive-expressions';
      common = require('/esmangle/lib/common.js', module);
      evaluator = require('/esmangle/lib/evaluator.js', module);
      escope = require('/escope/escope.js', module);
      Syntax = common.Syntax;
      function Transformer(trans, booleanFunction, voidFunction, scope) {
        this.transform = trans;
        this.booleanFunction = booleanFunction;
        this.voidFunction = voidFunction;
        this.scope = scope;
      }
      Transformer.prototype.booleanTransformation = function (expr) {
        var consequent;
        do {
          if (expr.type === Syntax.UnaryExpression) {
            if (expr.operator === '!' && expr.argument.type === Syntax.UnaryExpression && expr.argument.operator === '!') {
              modified = true;
              expr = expr.argument.argument;
              continue;
            }
          } else if (expr.type === Syntax.LogicalExpression) {
            if (expr.left.type === Syntax.UnaryExpression && expr.left.operator === '!' && expr.right.type === Syntax.UnaryExpression && expr.right.operator === '!') {
              modified = true;
              expr.left = expr.left.argument;
              expr.right = expr.right.argument;
              expr.operator = expr.operator === '||' ? '&&' : '||';
              expr = common.moveLocation(expr, {
                type: Syntax.UnaryExpression,
                operator: '!',
                argument: expr
              });
              continue;
            }
          } else if (expr.type === Syntax.ConditionalExpression) {
            if (expr.test.type === Syntax.UnaryExpression && expr.test.operator === '!') {
              modified = true;
              expr.test = expr.test.argument;
              consequent = expr.consequent;
              expr.consequent = expr.alternate;
              expr.alternate = consequent;
            }
          }
          break;
        } while (true);
        return expr;
      };
      Transformer.prototype.voidTransformation = function (expr) {
        var leftHasSideEffect, rightHasSideEffect;
        do {
          expr = this.booleanTransformation(expr);
          if (expr.type === Syntax.UnaryExpression) {
            if (expr.operator === '!' || expr.operator === 'void') {
              modified = true;
              expr = expr.argument;
              continue;
            }
          } else if (expr.type === Syntax.LogicalExpression) {
            if (expr.left.type === Syntax.UnaryExpression && expr.left.operator === '!') {
              modified = true;
              expr.left = expr.left.argument;
              expr.operator = expr.operator === '||' ? '&&' : '||';
            }
          } else if (expr.type === Syntax.ConditionalExpression) {
            leftHasSideEffect = evaluator.hasSideEffect(expr.consequent, this.scope);
            rightHasSideEffect = evaluator.hasSideEffect(expr.alternate, this.scope);
            if (!leftHasSideEffect && !rightHasSideEffect) {
              modified = true;
              expr = expr.test;
            } else if (!leftHasSideEffect) {
              modified = true;
              expr = common.moveLocation(expr, {
                type: Syntax.LogicalExpression,
                operator: '||',
                left: expr.test,
                right: expr.alternate
              });
            } else if (!rightHasSideEffect) {
              modified = true;
              expr = common.moveLocation(expr, {
                type: Syntax.LogicalExpression,
                operator: '&&',
                left: expr.test,
                right: expr.consequent
              });
            }
          }
          break;
        } while (true);
        return expr;
      };
      Transformer.prototype.apply = function (expr) {
        var prev;
        do {
          prev = expr;
          expr = this.transform(expr);
          if (prev !== expr) {
            continue;
          }
          if (expr.type === Syntax.LogicalExpression) {
            expr.left = this.booleanFunction(expr.left, this.scope);
            expr.right = this.voidFunction(expr.right, this.scope);
          } else if (expr.type === Syntax.ConditionalExpression) {
            expr.consequent = this.voidFunction(expr.consequent, this.scope);
            expr.alternate = this.voidFunction(expr.alternate, this.scope);
          } else if (expr.type === Syntax.SequenceExpression) {
            expr.expressions[expr.expressions.length - 1] = this.voidFunction(common.Array.last(expr.expressions), this.scope);
          }
          break;
        } while (true);
        return expr;
      };
      function voidContext(expr, scope) {
        var trans = new Transformer(Transformer.prototype.voidTransformation, booleanContext, voidContext, scope);
        return trans.apply(expr);
      }
      function booleanContext(expr, scope) {
        var trans = new Transformer(Transformer.prototype.booleanTransformation, booleanContext, booleanContext, scope);
        return trans.apply(expr);
      }
      function removeContextSensitiveExpressions(tree, options) {
        var result, stackCount, preserveCompletionValue, scope, manager;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        stackCount = 0;
        preserveCompletionValue = options.get('preserveCompletionValue', { pathName: Name });
        scope = null;
        manager = escope.analyze(result, { directive: true });
        manager.attach();
        result = common.replace(result, {
          enter: function enter(node) {
            var i, iz;
            scope = manager.acquire(node) || scope;
            if (node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration) {
              ++stackCount;
            }
            switch (node.type) {
            case Syntax.AssignmentExpression:
              break;
            case Syntax.ArrayExpression:
              break;
            case Syntax.BlockStatement:
              break;
            case Syntax.BinaryExpression:
              break;
            case Syntax.BreakStatement:
              break;
            case Syntax.CallExpression:
              break;
            case Syntax.CatchClause:
              break;
            case Syntax.ConditionalExpression:
              node.test = booleanContext(node.test, scope);
              break;
            case Syntax.ContinueStatement:
              break;
            case Syntax.DoWhileStatement:
              node.test = booleanContext(node.test, scope);
              break;
            case Syntax.DebuggerStatement:
              break;
            case Syntax.EmptyStatement:
              break;
            case Syntax.ExpressionStatement:
              if (!preserveCompletionValue || stackCount !== 0) {
                node.expression = voidContext(node.expression, scope);
              }
              break;
            case Syntax.FunctionExpression:
              break;
            case Syntax.ForInStatement:
              break;
            case Syntax.FunctionDeclaration:
              break;
            case Syntax.ForStatement:
              if (node.init && node.init.type !== Syntax.VariableDeclaration) {
                node.init = voidContext(node.init, scope);
              }
              if (node.test) {
                node.test = booleanContext(node.test, scope);
              }
              if (node.update) {
                node.update = voidContext(node.update, scope);
              }
              break;
            case Syntax.Identifier:
              break;
            case Syntax.IfStatement:
              node.test = booleanContext(node.test, scope);
              break;
            case Syntax.Literal:
              break;
            case Syntax.LabeledStatement:
              break;
            case Syntax.LogicalExpression:
              break;
            case Syntax.MemberExpression:
              break;
            case Syntax.NewExpression:
              break;
            case Syntax.ObjectExpression:
              break;
            case Syntax.Program:
              break;
            case Syntax.Property:
              break;
            case Syntax.ReturnStatement:
              break;
            case Syntax.SequenceExpression:
              for (i = 0, iz = node.expressions.length - 1; i < iz; ++i) {
                node.expressions[i] = voidContext(node.expressions[i], scope);
              }
              break;
            case Syntax.SwitchStatement:
              break;
            case Syntax.SwitchCase:
              break;
            case Syntax.ThisExpression:
              break;
            case Syntax.ThrowStatement:
              break;
            case Syntax.TryStatement:
              break;
            case Syntax.UnaryExpression:
              if (node.operator === '!') {
                node.argument = booleanContext(node.argument, scope);
              } else if (node.operator === 'void') {
                node.argument = voidContext(node.argument, scope);
              }
              break;
            case Syntax.UpdateExpression:
              break;
            case Syntax.VariableDeclaration:
              break;
            case Syntax.VariableDeclarator:
              break;
            case Syntax.WhileStatement:
              node.test = booleanContext(node.test, scope);
              break;
            case Syntax.WithStatement:
              break;
            }
          },
          leave: function leave(node) {
            scope = manager.release(node) || scope;
            if (node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration) {
              --stackCount;
            }
          }
        });
        manager.detach();
        return {
          result: result,
          modified: modified
        };
      }
      removeContextSensitiveExpressions.passName = Name;
      module.exports = removeContextSensitiveExpressions;
    }());
  });
  require.define('/esmangle/lib/pass/remove-side-effect-free-expressions.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, escope, evaluator, modified;
      Name = 'remove-side-effect-free-expressions';
      escope = require('/escope/escope.js', module);
      common = require('/esmangle/lib/common.js', module);
      evaluator = require('/esmangle/lib/evaluator.js', module);
      Syntax = common.Syntax;
      function reduce(node, scope, parent, isResultNeeded) {
        var i, iz, expr, result, prev;
        common.assert(node.expressions.length > 1, 'expressions should be more than one');
        result = [];
        for (i = 0, iz = node.expressions.length; i < iz; ++i) {
          prev = expr;
          expr = node.expressions[i];
          if (i + 1 !== iz || !isResultNeeded) {
            if (!evaluator.hasSideEffect(expr, scope)) {
              continue;
            }
          }
          result.push(expr);
        }
        if (!isResultNeeded && result.length === 0) {
          modified = true;
          return expr;
        }
        common.assert(result.length > 0, 'result should be more than zero');
        do {
          if (iz === result.length) {
            return node;
          }
          if (result.length === 1) {
            if (!common.SpecialNode.canExtractSequence(result[0], parent, scope)) {
              result.unshift(prev);
              continue;
            }
            modified = true;
            return result[0];
          }
          modified = true;
          node.expressions = result;
          return node;
        } while (true);
      }
      function removeSideEffectFreeExpressions(tree, options) {
        var result, scope, manager, preserveCompletionValue;
        function isResultNeeded(parent, scope) {
          if (parent.type === Syntax.ExpressionStatement && (!preserveCompletionValue || scope.type !== 'global')) {
            return false;
          }
          return true;
        }
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        preserveCompletionValue = options.get('preserveCompletionValue', { pathName: Name });
        modified = false;
        scope = null;
        manager = escope.analyze(result, { directive: true });
        manager.attach();
        result = common.replace(result, {
          enter: function enter(node, parent) {
            var res, unary, trans;
            res = node;
            scope = manager.acquire(node) || scope;
            if (res.type === Syntax.SequenceExpression) {
              res = reduce(res, scope, parent, isResultNeeded(parent, scope));
            }
            if (res.type === Syntax.SequenceExpression) {
              common.assert(res.expressions.length > 1, "sequences' length should be more than 1");
              unary = common.Array.last(res.expressions);
              if (unary.type === Syntax.UnaryExpression && unary.operator === 'void' && !evaluator.hasSideEffect(unary.argument, scope)) {
                modified = true;
                res.expressions.pop();
                trans = common.moveLocation(unary, {
                  type: Syntax.UnaryExpression,
                  operator: 'void',
                  argument: common.Array.last(res.expressions)
                });
                if (res.expressions.length === 1) {
                  res = trans;
                } else {
                  res.expressions[res.expressions.length - 1] = trans;
                }
              }
            }
            if (!isResultNeeded(res, scope)) {
              if (!evaluator.hasSideEffect(res.expression, scope)) {
                modified = true;
                res = common.moveLocation(res, { type: Syntax.EmptyStatement });
              }
            }
            return res;
          },
          leave: function leave(node) {
            scope = manager.release(node) || scope;
          }
        });
        manager.detach();
        return {
          result: result,
          modified: modified
        };
      }
      removeSideEffectFreeExpressions.passName = Name;
      module.exports = removeSideEffectFreeExpressions;
    }());
  });
  require.define('/esmangle/lib/pass/dead-code-elimination.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, status, modified;
      Name = 'dead-code-elimination';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function JumpTarget(node, status, type) {
        this.node = node;
        this.type = type;
        this.labels = status.labels || [];
        status.labels = null;
      }
      JumpTarget.NAMED_ONLY = 0;
      JumpTarget.ITERATION = 2;
      JumpTarget.SWITCH = 3;
      JumpTarget.prototype.isIteration = function isIteration() {
        return this.type === JumpTarget.ITERATION;
      };
      JumpTarget.prototype.isAnonymous = function isAnonymous() {
        return this.type & 2;
      };
      JumpTarget.prototype.contains = function contains(label) {
        return this.labels.indexOf(label) !== -1;
      };
      function Jumps() {
        this.targets = [];
      }
      Jumps.prototype.lookupContinuableTarget = function lookupContinuableTarget(label) {
        var i, target;
        for (i = this.targets.length - 1; i >= 0; --i) {
          target = this.targets[i];
          if (target.isIteration() && (!label || target.contains(label.name))) {
            return target.node;
          }
        }
        common.unreachable();
      };
      Jumps.prototype.lookupBreakableTarget = function lookupBreakableTarget(label) {
        var i, target;
        for (i = this.targets.length - 1; i >= 0; --i) {
          target = this.targets[i];
          if (label) {
            if (target.contains(label.name)) {
              return target.node;
            }
          } else {
            if (target.isAnonymous()) {
              return target.node;
            }
          }
        }
        common.unreachable();
      };
      Jumps.prototype.push = function push(target) {
        this.targets.push(target);
      };
      Jumps.prototype.pop = function pop() {
        this.targets.pop();
      };
      function Status(upper) {
        this.current = [];
        this.upper = upper;
        this.jumps = new Jumps;
        this.labels = null;
        this.next();
      }
      Status.NEXT = {};
      Status.prototype.insert = function insert(stmt) {
        this.current.push(stmt);
      };
      Status.prototype.erase = function erase(stmt) {
        var index = this.current.indexOf(stmt);
        if (index === -1) {
          return false;
        }
        this.current.splice(index, 1);
        return true;
      };
      Status.prototype.kill = function kill() {
        return this.erase(Status.NEXT);
      };
      Status.prototype.has = function has(stmt) {
        return this.current.indexOf(stmt) !== -1;
      };
      Status.prototype.jumpTo = function jumpTo(stmt) {
        this.kill();
        this.insert(stmt);
      };
      Status.prototype.resolveJump = function resolveJump(stmt) {
        var index = this.current.indexOf(stmt);
        if (index !== -1) {
          this.current.splice(index, 1);
          this.insert(Status.NEXT);
        }
      };
      Status.prototype.clear = function clear() {
        this.current.length = 0;
      };
      Status.prototype.next = function next() {
        this.insert(Status.NEXT);
      };
      Status.prototype.isDead = function isDead() {
        return !this.has(Status.NEXT);
      };
      Status.prototype.revive = function revive() {
        if (this.isDead()) {
          this.next();
          return true;
        }
        return false;
      };
      Status.prototype.register = function register(node) {
        if (!this.labels) {
          this.labels = [];
        }
        this.labels.push(node.label.name);
      };
      Status.prototype.unregister = function unregister() {
        this.labels = null;
      };
      Status.isRequired = function isRequired(node) {
        var type = node.type;
        common.assert(node, 'should be node');
        return type === Syntax.Program || type === Syntax.FunctionExpression || type === Syntax.FunctionDeclaration;
      };
      function Context(node) {
        node.__$context = this;
        this.node = node;
      }
      Context.prototype.detach = function detach() {
        delete this.node.__$context;
      };
      Context.lookup = function lookup(node) {
        return node.__$context;
      };
      function getForwardLastNode(node) {
        while (true) {
          switch (node.type) {
          case Syntax.IfStatement:
            if (node.alternate) {
              return null;
            }
            node = node.consequent;
            continue;
          case Syntax.WithStatement:
          case Syntax.LabeledStatement:
            node = node.body;
            continue;
          case Syntax.BlockStatement:
            if (node.body.length) {
              node = common.Array.last(node.body);
              continue;
            }
            break;
          }
          return node;
        }
      }
      function visitLoopBody(loop, body) {
        var jump, last;
        last = getForwardLastNode(body);
        if (last) {
          if (last.type === Syntax.ContinueStatement) {
            jump = status.jumps.lookupContinuableTarget(last.label);
            if (jump === loop) {
              modified = true;
              common.convertToEmptyStatement(last);
            }
          }
        }
        return visit(body);
      }
      function visit(target) {
        var live = false;
        if (!target) {
          return !status.isDead();
        }
        function eliminate(node, array) {
          var i, iz, stmt, ret, info, result;
          result = [];
          for (i = 0, iz = array.length; i < iz; ++i) {
            stmt = array[i];
            if (stmt.type === Syntax.IfStatement) {
              info = new Context(stmt);
              ret = visit(stmt);
              info.detach();
            } else {
              ret = visit(stmt);
            }
            if (ret) {
              live |= 1;
              result.push(stmt);
              if (stmt.type === Syntax.IfStatement && stmt.alternate) {
                if ((!info.consequent || !info.alternate) && info.consequent !== info.alternate) {
                  modified = true;
                  if (info.consequent) {
                    stmt.test = common.moveLocation(stmt.test, {
                      type: Syntax.UnaryExpression,
                      operator: '!',
                      argument: stmt.test
                    });
                    result.push(stmt.consequent);
                    stmt.consequent = stmt.alternate;
                    stmt.alternate = null;
                  } else {
                    result.push(stmt.alternate);
                    stmt.alternate = null;
                  }
                }
              }
            } else {
              modified = true;
            }
          }
          return result;
        }
        common.traverse(target, {
          enter: function enter(node) {
            var i, iz, stmt, consequent, alternate, ctx, hasDefaultClause;
            if (Status.isRequired(node)) {
              status = new Status(status);
            }
            live |= !status.isDead();
            switch (node.type) {
            case Syntax.Program:
              node.body = eliminate(node, node.body);
              return common.VisitorOption.Skip;
            case Syntax.BlockStatement:
              status.jumps.push(new JumpTarget(node, status, JumpTarget.NAMED_ONLY));
              node.body = eliminate(node, node.body);
              status.jumps.pop();
              status.resolveJump(node);
              return common.VisitorOption.Skip;
            case Syntax.BreakStatement:
              if (node.label && status.labels && status.labels.indexOf(node.label)) {
                modified = true;
                common.convertToEmptyStatement(node);
              } else {
                status.jumpTo(status.jumps.lookupBreakableTarget(node.label));
              }
              return common.VisitorOption.Skip;
            case Syntax.CatchClause:
              live |= visit(node.body);
              return common.VisitorOption.Skip;
            case Syntax.ContinueStatement:
              status.jumpTo(status.jumps.lookupContinuableTarget(node.label));
              return common.VisitorOption.Skip;
            case Syntax.DoWhileStatement:
              status.jumps.push(new JumpTarget(node, status, JumpTarget.ITERATION));
              live |= visitLoopBody(node, node.body);
              status.jumps.pop();
              live |= visit(node.test);
              status.resolveJump(node);
              status.revive();
              return common.VisitorOption.Skip;
            case Syntax.DebuggerStatement:
              return common.VisitorOption.Skip;
            case Syntax.EmptyStatement:
              return common.VisitorOption.Skip;
            case Syntax.ExpressionStatement:
              break;
            case Syntax.ForStatement:
              live |= visit(node.init);
              live |= visit(node.test);
              status.jumps.push(new JumpTarget(node, status, JumpTarget.ITERATION));
              live |= visitLoopBody(node, node.body);
              status.jumps.pop();
              live |= visit(node.update);
              status.resolveJump(node);
              status.revive();
              return common.VisitorOption.Skip;
            case Syntax.ForInStatement:
              live |= visit(node.left);
              live |= visit(node.right);
              status.jumps.push(new JumpTarget(node, status, JumpTarget.ITERATION));
              live |= visitLoopBody(node, node.body);
              status.jumps.pop();
              status.resolveJump(node);
              status.revive();
              return common.VisitorOption.Skip;
            case Syntax.IfStatement:
              live |= visit(node.test);
              live |= visit(node.consequent);
              if (!node.alternate) {
                status.revive();
                return common.VisitorOption.Skip;
              }
              consequent = !status.isDead();
              if (!status.revive()) {
                status.insert(node);
              }
              live |= visit(node.alternate);
              alternate = !status.isDead();
              if (status.erase(node)) {
                status.revive();
              }
              if (ctx = Context.lookup(node)) {
                ctx.consequent = consequent;
                ctx.alternate = alternate;
              }
              return common.VisitorOption.Skip;
            case Syntax.LabeledStatement:
              status.register(node);
              break;
            case Syntax.ReturnStatement:
              live |= visit(node.argument);
              status.kill();
              return common.VisitorOption.Skip;
            case Syntax.SwitchStatement:
              visit(node.discriminant);
              status.jumps.push(new JumpTarget(node, status, JumpTarget.SWITCH));
              for (i = 0, iz = node.cases.length; i < iz; ++i) {
                stmt = node.cases[i];
                live |= visit(stmt);
                if (!stmt.test) {
                  hasDefaultClause = true;
                }
                if (status.isDead() && i + 1 < iz) {
                  status.next();
                }
              }
              status.jumps.pop();
              status.resolveJump(node);
              if (status.isDead() && !hasDefaultClause) {
                status.next();
              }
              return common.VisitorOption.Skip;
            case Syntax.SwitchCase:
              if (node.test) {
                live |= visit(node.test);
              }
              node.consequent = eliminate(node, node.consequent);
              return common.VisitorOption.Skip;
            case Syntax.ThrowStatement:
              live |= visit(node.argument);
              status.kill();
              return common.VisitorOption.Skip;
            case Syntax.TryStatement:
              live |= visit(node.block);
              if (node.handlers && node.handlers.length) {
                if (!status.revive()) {
                  status.insert(node);
                }
                node.handlers = eliminate(node, node.handlers);
                if (status.erase(node)) {
                  status.revive();
                }
              }
              if (node.finalizer) {
                if (!status.revive()) {
                  status.insert(node);
                }
                live |= visit(node.finalizer);
                if (!status.erase(node)) {
                  status.kill();
                }
              }
              return common.VisitorOption.Skip;
            case Syntax.WhileStatement:
              live |= visit(node.test);
              status.jumps.push(new JumpTarget(node, status, JumpTarget.ITERATION));
              live |= visitLoopBody(node, node.body);
              status.jumps.pop();
              status.resolveJump(node);
              status.revive();
              return common.VisitorOption.Skip;
            case Syntax.WithStatement:
              break;
            case Syntax.VariableDeclaration:
            case Syntax.FunctionDeclaration:
              live = true;
              break;
            }
          },
          leave: function leave(node) {
            if (Status.isRequired(node)) {
              status = status.upper;
              return;
            }
            if (node.type === Syntax.LabeledStatement) {
              status.unregister();
            }
          }
        });
        return live;
      }
      function deadCodeElimination(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        status = null;
        modified = false;
        visit(result);
        common.assert(status === null, 'status should be null');
        return {
          result: result,
          modified: modified
        };
      }
      deadCodeElimination.passName = Name;
      module.exports = deadCodeElimination;
    }());
  });
  require.define('/esmangle/lib/pass/reduce-multiple-if-statements.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'reduce-multiple-if-statements';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function reduceMultipleIfStatements(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        common.traverse(result, {
          leave: function leave(node) {
            if (node.type === Syntax.IfStatement && !node.alternate && node.consequent.type === Syntax.IfStatement && !node.consequent.alternate) {
              modified = true;
              node.test = {
                type: Syntax.LogicalExpression,
                operator: '&&',
                left: node.test,
                right: node.consequent.test
              };
              node.consequent = node.consequent.consequent;
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      reduceMultipleIfStatements.passName = Name;
      module.exports = reduceMultipleIfStatements;
    }());
  });
  require.define('/esmangle/lib/pass/reduce-branch-jump.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'reduce-branch-jump';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function reduceLast(ary, index) {
        var node, left;
        node = ary[index];
        if (node.type === Syntax.IfStatement) {
          if (!node.alternate) {
            if (node.consequent.type === Syntax.ReturnStatement) {
              modified = true;
              left = node.consequent.argument;
              if (!left) {
                ary[index] = common.moveLocation(node, {
                  type: Syntax.ReturnStatement,
                  argument: {
                    type: Syntax.SequenceExpression,
                    expressions: [
                      node.test,
                      common.SpecialNode.generateUndefined()
                    ]
                  }
                });
                return true;
              }
              ary[index] = common.moveLocation(node, {
                type: Syntax.ReturnStatement,
                argument: {
                  type: Syntax.ConditionalExpression,
                  test: node.test,
                  consequent: left,
                  alternate: common.SpecialNode.generateUndefined()
                }
              });
              return true;
            }
          }
        }
      }
      function reduce(ary, index) {
        var node, sibling, left, right;
        node = ary[index];
        sibling = ary[index + 1];
        if (node.type === Syntax.IfStatement) {
          if (!node.alternate) {
            if (node.consequent.type === Syntax.ReturnStatement && sibling.type === Syntax.ReturnStatement) {
              modified = true;
              ary.splice(index, 1);
              left = node.consequent.argument;
              right = sibling.argument;
              if (!left && !right) {
                ary[index] = common.moveLocation(node, {
                  type: Syntax.ReturnStatement,
                  argument: {
                    type: Syntax.SequenceExpression,
                    expressions: [
                      node.test,
                      common.SpecialNode.generateUndefined()
                    ]
                  }
                });
                return true;
              }
              if (!left) {
                left = common.SpecialNode.generateUndefined();
              }
              if (!right) {
                right = common.SpecialNode.generateUndefined();
              }
              ary[index] = common.moveLocation(node, {
                type: Syntax.ReturnStatement,
                argument: {
                  type: Syntax.ConditionalExpression,
                  test: node.test,
                  consequent: left,
                  alternate: right
                }
              });
              return true;
            }
          }
        }
        return false;
      }
      function reduceBranchJump(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        common.traverse(result, {
          leave: function leave(node, parent) {
            var i;
            switch (node.type) {
            case Syntax.BlockStatement:
            case Syntax.Program:
              i = 0;
              while (i < node.body.length - 1) {
                if (!reduce(node.body, i)) {
                  ++i;
                }
              }
              if (common.isFunctionBody(node, parent)) {
                if (node.body.length > 0) {
                  i = node.body.length - 1;
                  reduceLast(node.body, i);
                }
              }
              break;
            case Syntax.SwitchCase:
              i = 0;
              while (i < node.consequent.length - 1) {
                if (!reduce(node.consequent, i)) {
                  ++i;
                }
              }
              break;
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      reduceBranchJump.passName = Name;
      module.exports = reduceBranchJump;
    }());
  });
  require.define('/esmangle/lib/pass/reduce-sequence-expression.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, evaluator, escope, modified;
      Name = 'reduce-sequence-expression';
      escope = require('/escope/escope.js', module);
      common = require('/esmangle/lib/common.js', module);
      evaluator = require('/esmangle/lib/evaluator.js', module);
      Syntax = common.Syntax;
      function reduce(node) {
        var i, iz, j, jz, expr, result;
        result = [];
        for (i = 0, iz = node.expressions.length; i < iz; ++i) {
          expr = node.expressions[i];
          if (expr.type === Syntax.SequenceExpression) {
            modified = true;
            common.deleteLocation(node);
            for (j = 0, jz = expr.expressions.length; j < jz; ++j) {
              result.push(expr.expressions[j]);
            }
          } else {
            result.push(expr);
          }
        }
        node.expressions = result;
      }
      function isLoadSideEffectFree(node, scope) {
        var ref, value;
        if (evaluator.constant.isConstant(node)) {
          value = evaluator.constant.evaluate(node);
          if (value === null || typeof value !== 'object') {
            return true;
          }
        }
        if (node.type === Syntax.Identifier) {
          ref = scope.resolve(node);
          return ref && ref.isStatic();
        }
        return false;
      }
      function isStoreSideEffectFree(node, scope) {
        if (!evaluator.hasSideEffect(node, scope)) {
          return true;
        }
        if (node.type === Syntax.Identifier) {
          return true;
        }
        if (node.type === Syntax.MemberExpression) {
          if (!evaluator.hasSideEffect(node.object, scope)) {
            if (!node.computed || isLoadSideEffectFree(node.property, scope)) {
              return true;
            }
          }
          return false;
        }
        return false;
      }
      function reduceSequenceExpression(tree, options) {
        var result, scope, manager;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        scope = null;
        manager = escope.analyze(result, { directive: true });
        manager.attach();
        result = common.replace(result, {
          enter: function enter(node) {
            scope = manager.acquire(node) || scope;
          },
          leave: function leave(node) {
            var result, last;
            switch (node.type) {
            case Syntax.SequenceExpression:
              reduce(node);
              break;
            case Syntax.ConditionalExpression:
              if (node.test.type === Syntax.SequenceExpression) {
                modified = true;
                result = node.test;
                node.test = common.Array.last(result.expressions);
                result.expressions[result.expressions.length - 1] = node;
              }
              break;
            case Syntax.LogicalExpression:
              if (node.left.type === Syntax.SequenceExpression) {
                modified = true;
                result = node.left;
                node.left = common.Array.last(result.expressions);
                result.expressions[result.expressions.length - 1] = node;
              }
              break;
            case Syntax.BinaryExpression:
              if (node.left.type === Syntax.SequenceExpression) {
                modified = true;
                result = node.left;
                node.left = common.Array.last(result.expressions);
                result.expressions[result.expressions.length - 1] = node;
              } else if (node.right.type === Syntax.SequenceExpression && !evaluator.hasSideEffect(node.left, scope)) {
                modified = true;
                result = node.right;
                node.right = common.Array.last(result.expressions);
                result.expressions[result.expressions.length - 1] = node;
              }
              break;
            case Syntax.UpdateExpression:
            case Syntax.UnaryExpression:
              if (node.argument.type === Syntax.SequenceExpression) {
                last = common.Array.last(node.argument.expressions);
                if (!common.SpecialNode.canExtractSequence(last, node, scope)) {
                  break;
                }
                modified = true;
                result = node.argument;
                node.argument = common.Array.last(result.expressions);
                result.expressions[result.expressions.length - 1] = node;
              }
              break;
            case Syntax.AssignmentExpression:
              if (node.operator === '=' && node.right.type === Syntax.SequenceExpression && isStoreSideEffectFree(node.left, scope)) {
                modified = true;
                result = node.right;
                node.right = common.Array.last(result.expressions);
                result.expressions[result.expressions.length - 1] = node;
              }
              break;
            }
            scope = manager.release(node) || scope;
            return result;
          }
        });
        manager.detach();
        return {
          result: result,
          modified: modified
        };
      }
      reduceSequenceExpression.passName = Name;
      module.exports = reduceSequenceExpression;
    }());
  });
  require.define('/esmangle/lib/pass/transform-typeof-undefined.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, escope, modified;
      Name = 'transform-typeof-undefined';
      escope = require('/escope/escope.js', module);
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function isUndefinedStringLiteral(node) {
        return node.type === Syntax.Literal && node.value === 'undefined';
      }
      function transformTypeofUndefined(tree, options) {
        var result, manager, scope;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        scope = null;
        manager = escope.analyze(result, { directive: true });
        manager.attach();
        common.traverse(result, {
          enter: function enter(node) {
            var target, undef, argument, ref;
            scope = manager.acquire(node) || scope;
            if (node.type === Syntax.BinaryExpression && (node.operator === '===' || node.operator === '!==' || node.operator === '==' || node.operator === '!=')) {
              if (isUndefinedStringLiteral(node.left)) {
                undef = 'left';
                target = 'right';
              } else if (isUndefinedStringLiteral(node.right)) {
                undef = 'right';
                target = 'left';
              } else {
                return;
              }
              if (node[target].type === Syntax.UnaryExpression && node[target].operator === 'typeof') {
                argument = node[target].argument;
                if (argument.type === Syntax.Identifier) {
                  ref = scope.resolve(argument);
                  if (!ref || !ref.isStatic() || !ref.resolved) {
                    return;
                  }
                }
                modified = true;
                node[undef] = common.SpecialNode.generateUndefined();
                node[target] = argument;
                node.operator = node.operator.charAt(0) === '!' ? '!==' : '===';
              }
            }
          },
          leave: function leave(node) {
            scope = manager.release(node) || scope;
          }
        });
        manager.detach();
        return {
          result: result,
          modified: modified
        };
      }
      transformTypeofUndefined.passName = Name;
      module.exports = transformTypeofUndefined;
    }());
  });
  require.define('/esmangle/lib/pass/transform-branch-to-expression.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'transform-branch-to-expression';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function transformBranchToExpression(tree, options) {
        var result, preserveCompletionValue;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        preserveCompletionValue = options.get('preserveCompletionValue', { pathName: Name });
        modified = false;
        result = common.replace(result, {
          leave: function leave(node) {
            var consequent, alternate, ancestors;
            if (node.type === Syntax.IfStatement) {
              ancestors = this.parents();
              if (preserveCompletionValue && common.mayBeCompletionValue(node, ancestors)) {
                return;
              }
              if (node.alternate) {
                if (node.consequent.type === Syntax.ExpressionStatement && node.alternate.type === Syntax.ExpressionStatement) {
                  modified = true;
                  return common.moveLocation(node, {
                    type: Syntax.ExpressionStatement,
                    expression: common.moveLocation(node, {
                      type: Syntax.ConditionalExpression,
                      test: node.test,
                      consequent: node.consequent.expression,
                      alternate: node.alternate.expression
                    })
                  });
                }
                if (node.consequent.type === Syntax.ReturnStatement && node.alternate.type === Syntax.ReturnStatement) {
                  modified = true;
                  if (!node.consequent.argument && !node.alternate.argument) {
                    return common.moveLocation(node, {
                      type: Syntax.ReturnStatement,
                      argument: common.moveLocation(node, {
                        type: Syntax.SequenceExpression,
                        expressions: [
                          node.test,
                          common.SpecialNode.generateUndefined()
                        ]
                      })
                    });
                  }
                  consequent = node.consequent.argument || common.SpecialNode.generateUndefined();
                  alternate = node.alternate.argument || common.SpecialNode.generateUndefined();
                  return common.moveLocation(node, {
                    type: Syntax.ReturnStatement,
                    argument: common.moveLocation(node, {
                      type: Syntax.ConditionalExpression,
                      test: node.test,
                      consequent: consequent,
                      alternate: alternate
                    })
                  });
                }
                if (node.consequent.type === Syntax.ThrowStatement && node.alternate.type === Syntax.ThrowStatement) {
                  modified = true;
                  return common.moveLocation(node, {
                    type: Syntax.ThrowStatement,
                    argument: common.moveLocation(node, {
                      type: Syntax.ConditionalExpression,
                      test: node.test,
                      consequent: node.consequent.argument,
                      alternate: node.alternate.argument
                    })
                  });
                }
              } else {
                if (node.consequent.type === Syntax.ExpressionStatement) {
                  modified = true;
                  return common.moveLocation(node, {
                    type: Syntax.ExpressionStatement,
                    expression: common.moveLocation(node, {
                      type: Syntax.LogicalExpression,
                      operator: '&&',
                      left: node.test,
                      right: node.consequent.expression
                    })
                  });
                } else if (node.consequent.type === Syntax.EmptyStatement) {
                  modified = true;
                  return common.moveLocation(node, {
                    type: Syntax.ExpressionStatement,
                    expression: node.test
                  });
                }
              }
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      transformBranchToExpression.passName = Name;
      module.exports = transformBranchToExpression;
    }());
  });
  require.define('/esmangle/lib/pass/transform-to-sequence-expression.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'transform-to-sequence-expression';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function transform(node) {
        var i, iz, expressions, stmt, prev, body;
        function constructSeq(expressions, stmt) {
          var seq;
          if (expressions.length !== 1) {
            modified = true;
            seq = {
              type: Syntax.SequenceExpression,
              expressions: expressions
            };
            if (stmt.type === Syntax.ExpressionStatement) {
              stmt.expression = seq;
            } else {
              stmt.argument = seq;
            }
          }
          return stmt;
        }
        body = [];
        expressions = [];
        for (i = 0, iz = node.body.length; i < iz; ++i) {
          prev = stmt;
          stmt = node.body[i];
          if (stmt.type === Syntax.ExpressionStatement) {
            expressions.push(stmt.expression);
          } else if (stmt.type === Syntax.ReturnStatement && stmt.argument != null || stmt.type === Syntax.ThrowStatement) {
            expressions.push(stmt.argument);
            body.push(constructSeq(expressions, stmt));
            expressions = [];
          } else if (stmt.type === Syntax.ForStatement && (!stmt.init || stmt.init.type !== Syntax.VariableDeclaration)) {
            if (expressions.length) {
              modified = true;
              if (stmt.init) {
                expressions.push(stmt.init);
              }
              if (expressions.length === 1) {
                stmt.init = expressions[0];
              } else {
                stmt.init = {
                  type: Syntax.SequenceExpression,
                  expressions: expressions
                };
              }
              expressions = [];
            }
            body.push(stmt);
          } else if (stmt.type === Syntax.IfStatement) {
            if (expressions.length) {
              modified = true;
              expressions.push(stmt.test);
              stmt.test = {
                type: Syntax.SequenceExpression,
                expressions: expressions
              };
              expressions = [];
            }
            body.push(stmt);
          } else {
            if (expressions.length) {
              body.push(constructSeq(expressions, prev));
              expressions = [];
            }
            body.push(stmt);
          }
        }
        if (expressions.length) {
          body.push(constructSeq(expressions, stmt));
        }
        node.body = body;
      }
      function transformToSequenceExpression(tree, options) {
        var result;
        modified = false;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        common.traverse(result, {
          enter: function enter(node) {
            switch (node.type) {
            case Syntax.BlockStatement:
            case Syntax.Program:
              transform(node);
              break;
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      transformToSequenceExpression.passName = Name;
      module.exports = transformToSequenceExpression;
    }());
  });
  require.define('/esmangle/lib/pass/transform-to-compound-assignment.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, escope, modified;
      Name = 'transform-to-compound-assignment';
      escope = require('/escope/escope.js', module);
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function equals(lhs, rhs) {
        if (lhs.type !== rhs.type) {
          return false;
        }
        if (lhs.type === Syntax.Identifier) {
          return lhs.name === rhs.name;
        }
        return false;
      }
      function compound(operator) {
        switch (operator) {
        case '*':
        case '/':
        case '%':
        case '+':
        case '-':
        case '<<':
        case '>>':
        case '>>>':
        case '&':
        case '^':
        case '|':
          return operator + '=';
        }
        return null;
      }
      function observableCompound(operator) {
        switch (operator) {
        case '*=':
        case '/=':
        case '%=':
        case '+=':
        case '-=':
        case '<<=':
        case '>>=':
        case '>>>=':
        case '&=':
        case '^=':
        case '|=':
          return operator;
        }
        return null;
      }
      function transformToCompoundAssignment(tree, options) {
        var result, scope, manager;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        scope = null;
        manager = escope.analyze(result, { directive: true });
        manager.attach();
        common.traverse(result, {
          enter: function enter(node) {
            var left, right, operator, ref;
            scope = manager.acquire(node) || scope;
            if (node.type === Syntax.AssignmentExpression && node.operator === '=') {
              left = node.left;
              right = node.right;
              if (right.type === Syntax.BinaryExpression && equals(right.left, left)) {
                operator = compound(right.operator);
                if (operator) {
                  modified = true;
                  node.operator = operator;
                  node.right = right.right;
                }
              } else if (right.type === Syntax.AssignmentExpression && equals(right.left, left)) {
                if (observableCompound(right.operator)) {
                  ref = scope.resolve(node.left);
                  if (ref.isStatic()) {
                    modified = true;
                    node.operator = right.operator;
                    node.right = right.right;
                  }
                }
              }
            }
          },
          leave: function leave(node) {
            scope = manager.release(node) || scope;
          }
        });
        manager.detach();
        return {
          result: result,
          modified: modified
        };
      }
      transformToCompoundAssignment.passName = Name;
      module.exports = transformToCompoundAssignment;
    }());
  });
  require.define('/esmangle/lib/pass/remove-wasted-blocks.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'remove-wasted-blocks';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function flattenBlockStatement(body) {
        var i, iz, j, jz, result, stmt, inner, ok;
        result = [];
        for (i = 0, iz = body.length; i < iz; ++i) {
          stmt = body[i];
          if (stmt.type === Syntax.BlockStatement) {
            ok = true;
            for (j = 0, jz = stmt.body.length; j < jz; ++j) {
              inner = stmt.body[j];
              if (common.isScopedDeclaration(inner)) {
                ok = false;
              }
            }
            if (ok) {
              modified = true;
              result = result.concat(stmt.body);
            } else {
              result.push(stmt);
            }
          } else {
            result.push(stmt);
          }
        }
        return result;
      }
      function removeWastedBlocks(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        result = common.replace(result, {
          leave: function leave(node, parent) {
            var i, iz, stmt;
            if (node.type === Syntax.BlockStatement || node.type === Syntax.Program) {
              for (i = 0, iz = node.body.length; i < iz; ++i) {
                stmt = node.body[i];
                if (stmt.type === Syntax.BlockStatement) {
                  node.body = flattenBlockStatement(node.body);
                  break;
                }
              }
            }
            if (parent.type === Syntax.FunctionDeclaration || parent.type === Syntax.FunctionExpression || parent.type === Syntax.TryStatement || parent.type === Syntax.CatchClause) {
              return;
            }
            while (node.type === Syntax.BlockStatement && node.body.length === 1 && !common.isScopedDeclaration(node.body[0])) {
              modified = true;
              node = node.body[0];
            }
            if (node.type === Syntax.BlockStatement && node.body.length === 0) {
              modified = true;
              return { type: Syntax.EmptyStatement };
            }
            return node;
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      removeWastedBlocks.passName = Name;
      module.exports = removeWastedBlocks;
    }());
  });
  require.define('/esmangle/lib/pass/remove-empty-statement.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'remove-empty-statement';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function remove(array) {
        var i, iz, node, result;
        result = [];
        for (i = 0, iz = array.length; i < iz; ++i) {
          node = array[i];
          if (node.type === Syntax.EmptyStatement) {
            modified = true;
          } else {
            result.push(node);
          }
        }
        return result;
      }
      function removeAlternate(node) {
        if (node.alternate) {
          if (node.alternate.type === Syntax.EmptyStatement) {
            modified = true;
            node.alternate = null;
          } else if (node.consequent.type === Syntax.EmptyStatement) {
            modified = true;
            node.consequent = node.alternate;
            node.alternate = null;
            node.test = common.moveLocation(node.test, {
              type: Syntax.UnaryExpression,
              operator: '!',
              argument: node.test
            });
          }
        }
      }
      function removeEmptyStatement(tree, options) {
        var result;
        modified = false;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        common.traverse(result, {
          enter: function enter(node) {
            var clause;
            switch (node.type) {
            case Syntax.BlockStatement:
            case Syntax.Program:
              node.body = remove(node.body);
              break;
            case Syntax.SwitchCase:
              node.consequent = remove(node.consequent);
              break;
            case Syntax.IfStatement:
              removeAlternate(node);
              break;
            case Syntax.SwitchStatement:
              if (node.cases.length) {
                clause = common.Array.last(node.cases);
                if (!clause.test && common.Array.empty(clause.consequent)) {
                  modified = true;
                  node.cases.pop();
                }
              }
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      removeEmptyStatement.passName = Name;
      module.exports = removeEmptyStatement;
    }());
  });
  require.define('/esmangle/lib/pass/remove-unused-label.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, Map, common, scope, modified;
      Name = 'remove-unused-label';
      common = require('/esmangle/lib/common.js', module);
      Map = require('/esmangle/lib/map.js', module);
      Syntax = common.Syntax;
      function Scope(upper) {
        this.set = new Map;
        this.unused = [];
        this.upper = upper;
      }
      Scope.prototype.register = function register(node) {
        var name;
        common.assert(node.type === Syntax.LabeledStatement);
        name = node.label.name;
        common.assert(!this.set.has(name), 'duplicate label is found');
        this.set.set(name, {
          used: false,
          stmt: node
        });
      };
      Scope.prototype.unregister = function unregister(node) {
        var name, ref;
        if (node.type === Syntax.LabeledStatement) {
          name = node.label.name;
          ref = this.set.get(name);
          this.set['delete'](name);
          if (!ref.used) {
            modified = true;
            return node.body;
          }
        }
        return node;
      };
      Scope.prototype.resolve = function resolve(node) {
        var name;
        if (node.label) {
          name = node.label.name;
          common.assert(this.set.has(name), 'unresolved label');
          this.set.get(name).used = true;
        }
      };
      Scope.prototype.close = function close() {
        return this.upper;
      };
      function removeUnusedLabel(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        scope = null;
        modified = false;
        result = common.replace(result, {
          enter: function enter(node) {
            switch (node.type) {
            case Syntax.Program:
            case Syntax.FunctionDeclaration:
            case Syntax.FunctionExpression:
              scope = new Scope(scope);
              break;
            case Syntax.LabeledStatement:
              scope.register(node);
              break;
            case Syntax.BreakStatement:
            case Syntax.ContinueStatement:
              scope.resolve(node);
              break;
            }
          },
          leave: function leave(node) {
            var ret;
            ret = scope.unregister(node);
            if (node.type === Syntax.Program || node.type === Syntax.FunctionDeclaration || node.type === Syntax.FunctionExpression) {
              scope = scope.close();
            }
            return ret;
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      removeUnusedLabel.passName = Name;
      module.exports = removeUnusedLabel;
    }());
  });
  require.define('/esmangle/lib/pass/reordering-function-declarations.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'reordering-function-declarations';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function reordering(array) {
        var i, iz, node, directives, declarations, others;
        directives = [];
        declarations = [];
        others = [];
        for (i = 0, iz = array.length; i < iz; ++i) {
          node = array[i];
          if (node.type === Syntax.FunctionDeclaration) {
            if (declarations.length + directives.length !== i) {
              modified = true;
            }
            declarations.push(node);
          } else if (node.type === Syntax.DirectiveStatement) {
            directives.push(node);
          } else {
            others.push(node);
          }
        }
        return directives.concat(declarations, others);
      }
      function reorderingFunctionDeclarations(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        common.traverse(result, {
          leave: function leave(node) {
            switch (node.type) {
            case Syntax.Program:
              node.body = reordering(node.body);
              break;
            case Syntax.FunctionDeclaration:
            case Syntax.FunctionExpression:
              node.body.body = reordering(node.body.body);
              break;
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      reorderingFunctionDeclarations.passName = Name;
      module.exports = reorderingFunctionDeclarations;
    }());
  });
  require.define('/esmangle/lib/pass/transform-logical-association.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'transform-logical-association';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function transformLogicalAssociation(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        common.traverse(result, {
          enter: function enter(node) {
            if (node.type === Syntax.LogicalExpression) {
              if (node.right.type === Syntax.LogicalExpression && node.operator === node.right.operator) {
                modified = true;
                node.left = {
                  type: Syntax.LogicalExpression,
                  operator: node.operator,
                  left: node.left,
                  right: node.right.left
                };
                node.right = node.right.right;
              }
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      transformLogicalAssociation.passName = Name;
      module.exports = transformLogicalAssociation;
    }());
  });
  require.define('/esmangle/lib/pass/transform-immediate-function-call.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'transform-immediate-function-call';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function isEmptyFunctionCall(call) {
        var callee, i, iz, stmt;
        if (call.type !== Syntax.CallExpression) {
          return false;
        }
        callee = call.callee;
        if (callee.type !== Syntax.FunctionExpression) {
          return false;
        }
        if (callee.body.type !== Syntax.BlockStatement) {
          return false;
        }
        if (callee.body.body.length === 0) {
          return true;
        }
        for (i = 0, iz = callee.body.body.length; i < iz; ++i) {
          stmt = callee.body.body[i];
          if (stmt.type !== Syntax.FunctionDeclaration) {
            return false;
          }
        }
        return true;
      }
      function callToSequence(call) {
        var expressions;
        expressions = common.Array.from(call['arguments']);
        if (expressions.length === 0) {
          return common.SpecialNode.generateUndefined(call);
        }
        expressions.push(common.SpecialNode.generateUndefined());
        return common.moveLocation(call, {
          type: Syntax.SequenceExpression,
          expressions: expressions
        });
      }
      function transformImmediateFunctionCall(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        result = common.replace(result, {
          leave: function leave(node) {
            if (isEmptyFunctionCall(node)) {
              modified = true;
              return callToSequence(node);
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      transformImmediateFunctionCall.passName = Name;
      module.exports = transformImmediateFunctionCall;
    }());
  });
  require.define('/esmangle/lib/pass/transform-dynamic-to-static-property-definition.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'transform-dynamic-to-static-property-definition';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function transformDynamicToStaticPropertyDefinition(tree, options) {
        var result;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        common.traverse(result, {
          enter: function enter(node) {
            var generated;
            if (node.type === Syntax.Property) {
              if (node.key.type === Syntax.Literal && typeof node.key.value === 'string') {
                if (common.isIdentifier(node.key.value)) {
                  modified = true;
                  node.key = common.moveLocation(node.key, {
                    type: Syntax.Identifier,
                    name: node.key.value
                  });
                } else if (node.key.value === Number(node.key.value).toString()) {
                  generated = common.SpecialNode.generateFromValue(Number(node.key.value));
                  if (generated.type === Syntax.Literal) {
                    modified = true;
                    node.key = common.moveLocation(node.key, generated);
                  }
                }
              }
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      transformDynamicToStaticPropertyDefinition.passName = Name;
      module.exports = transformDynamicToStaticPropertyDefinition;
    }());
  });
  require.define('/esmangle/lib/pass/transform-dynamic-to-static-property-access.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, modified;
      Name = 'transform-dynamic-to-static-property-access';
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function transformDynamicToStaticPropertyAccess(tree, options) {
        var result;
        modified = false;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        common.traverse(result, {
          enter: function enter(node) {
            var property;
            if (node.type === Syntax.MemberExpression && node.computed) {
              property = node.property;
              if (property.type === Syntax.Literal && typeof property.value === 'string') {
                if (common.isIdentifier(property.value)) {
                  modified = true;
                  node.computed = false;
                  node.property = common.moveLocation(property, {
                    type: Syntax.Identifier,
                    name: property.value
                  });
                } else if (property.value === Number(property.value).toString()) {
                  modified = true;
                  node.computed = true;
                  node.property = common.moveLocation(node.property, common.SpecialNode.generateFromValue(Number(node.property.value)));
                }
              }
            }
          }
        });
        return {
          result: result,
          modified: modified
        };
      }
      transformDynamicToStaticPropertyAccess.passName = Name;
      module.exports = transformDynamicToStaticPropertyAccess;
    }());
  });
  require.define('/esmangle/lib/pass/hoist-variable-to-arguments.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Name, Syntax, common, escope, modified;
      Name = 'hoist-variable-to-arguments';
      escope = require('/escope/escope.js', module);
      common = require('/esmangle/lib/common.js', module);
      Syntax = common.Syntax;
      function hoist(callee) {
        function hoisting(ident) {
          var hoisted, i, iz;
          hoisted = false;
          for (i = 0, iz = callee.params.length; i < iz; ++i) {
            if (ident.name === callee.params[i].name) {
              hoisted = true;
              break;
            }
          }
          if (!hoisted) {
            callee.params.push(ident);
          }
        }
        callee.body = common.replace(callee.body, {
          enter: function (node, parent) {
            var i, iz, expressions, declaration, forstmt, expr;
            if (node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration) {
              this.skip();
              return;
            }
            if (node.type === Syntax.VariableDeclaration && node.kind === 'var') {
              if (parent.type === Syntax.ForInStatement) {
                common.assert(node.declarations.length === 1, 'for-in declaration length should be 1');
                declaration = node.declarations[0];
                if (declaration.init) {
                  return;
                }
                if (declaration.id.type !== Syntax.Identifier) {
                  return;
                }
                hoisting(declaration.id);
                modified = true;
                return declaration.id;
              }
              forstmt = parent.type === Syntax.ForStatement;
              expressions = [];
              for (i = 0, iz = node.declarations.length; i < iz; ++i) {
                declaration = node.declarations[i];
                if (declaration.id.type !== Syntax.Identifier) {
                  return;
                }
                hoisting(declaration.id);
                if (declaration.init) {
                  expressions.push(common.moveLocation(declaration, {
                    type: Syntax.AssignmentExpression,
                    operator: '=',
                    left: declaration.id,
                    right: declaration.init
                  }));
                }
              }
              modified = true;
              if (expressions.length === 0) {
                if (forstmt) {
                  return null;
                }
                return common.moveLocation(node, { type: Syntax.EmptyStatement });
              }
              if (expressions.length === 1) {
                expr = expressions[0];
              } else {
                expr = common.moveLocation(node, {
                  type: Syntax.SequenceExpression,
                  expressions: expressions
                });
              }
              if (forstmt) {
                return expr;
              }
              return common.moveLocation(node, {
                type: Syntax.ExpressionStatement,
                expression: expr
              });
            }
          }
        });
      }
      function hoistVariableToArguments(tree, options) {
        var result, scope, manager;
        result = options.get('destructive', { pathName: Name }) ? tree : common.deepCopy(tree);
        modified = false;
        scope = null;
        manager = escope.analyze(result, { directive: true });
        manager.attach();
        common.traverse(result, {
          enter: function enter(node) {
            var callee;
            if (node.type === Syntax.CallExpression || node.type === Syntax.NewExpression) {
              callee = node.callee;
              if (callee.type === Syntax.FunctionExpression && !callee.id) {
                if (callee.params.length === node['arguments'].length) {
                  scope = manager.acquire(callee);
                  if (!scope.isArgumentsMaterialized() && (node.type !== Syntax.NewExpression || !scope.isThisMaterialized())) {
                    hoist(callee);
                  }
                }
              }
            }
          }
        });
        manager.detach();
        return {
          result: result,
          modified: modified
        };
      }
      hoistVariableToArguments.passName = Name;
      module.exports = hoistVariableToArguments;
    }());
  });
  require.define('/esmangle/lib/query.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var common;
      common = require('/esmangle/lib/common.js', module);
      exports.get = function get(root, query) {
        var i, iz, name, node;
        node = root;
        for (i = 0, iz = query.length; i < iz; ++i) {
          name = query[i];
          node = node[name];
        }
        return node;
      };
      exports.set = function set(root, query, value) {
        var i, iz, name, node;
        common.assert(query.length > 0);
        node = root;
        for (i = 0, iz = query.length - 1; i < iz; ++i) {
          name = query[i];
          node = node[name];
        }
        name = query[i];
        node[name] = value;
      };
    }());
  });
  require.define('/esmangle/lib/options.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var common;
      common = require('/esmangle/lib/common.js', module);
      function extend(result, update) {
        var prop, lhs, rhs;
        for (prop in update) {
          if (!common.Object.has(update, prop)) {
            continue;
          }
          if (prop in result) {
            lhs = result[prop];
            rhs = update[prop];
            if (common.Object.isObject(rhs) && common.Object.isObject(lhs)) {
              result[prop] = extend(lhs, rhs);
            } else {
              result[prop] = update[prop];
            }
          } else {
            result[prop] = update[prop];
          }
        }
        return result;
      }
      function Options(override) {
        var defaults = {
            destructive: true,
            preserveCompletionValue: false
          };
        if (override == null) {
          this.data = defaults;
          return;
        }
        this.data = extend(defaults, override);
      }
      Options.prototype.get = function get(name, details) {
        var local;
        if (details != null) {
          if (common.Object.has(details, 'pathName')) {
            local = this.data[details.pathName];
            if (local != null && common.Object.has(local, name)) {
              return local[name];
            }
          }
        }
        return this.data[name];
      };
      module.exports = Options;
    }());
  });
  require.define('/esshorten/lib/esshorten.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var escope, estraverse, esutils, utility, version, assert, Syntax, Map;
      escope = require('/escope/escope.js', module);
      estraverse = require('/esshorten/node_modules/estraverse/estraverse.js', module);
      esutils = require('/esshorten/node_modules/esutils/lib/utils.js', module);
      utility = require('/esshorten/lib/utility.js', module);
      Map = require('/esshorten/lib/map.js', module);
      version = require('/esshorten/package.json', module).version;
      Syntax = estraverse.Syntax;
      assert = function assert(cond, message) {
        if (!cond) {
          throw new Error(message);
        }
      };
      if (version.indexOf('-dev', version.length - 4) === -1) {
        assert = function () {
        };
      }
      function NameGenerator(scope, options) {
        this._scope = scope;
        this._functionName = '';
        if (!options.distinguishFunctionExpressionScope && this._scope.upper && this._scope.upper.functionExpressionScope) {
          this._functionName = this._scope.upper.block.id.name;
        }
      }
      NameGenerator.prototype.passAsUnique = function passAsUnique(name) {
        var i, iz;
        if (this._functionName === name) {
          return false;
        }
        if (esutils.keyword.isKeywordES5(name, true) || esutils.keyword.isRestrictedWord(name)) {
          return false;
        }
        if (this._scope.taints.has(name)) {
          return false;
        }
        for (i = 0, iz = this._scope.through.length; i < iz; ++i) {
          if (this._scope.through[i].identifier.name === name) {
            return false;
          }
        }
        return true;
      };
      NameGenerator.prototype.generateName = function generateName(tip) {
        do {
          tip = utility.generateNextName(tip);
        } while (!this.passAsUnique(tip));
        return tip;
      };
      function run(scope, options) {
        var i, iz, j, jz, variable, name, def, ref, generator;
        generator = new NameGenerator(scope, options);
        if (scope.isStatic()) {
          name = '9';
          scope.variables.sort(function (a, b) {
            if (a.tainted) {
              return 1;
            }
            if (b.tainted) {
              return -1;
            }
            return b.identifiers.length + b.references.length - (a.identifiers.length + a.references.length);
          });
          for (i = 0, iz = scope.variables.length; i < iz; ++i) {
            variable = scope.variables[i];
            if (variable.tainted) {
              continue;
            }
            if (variable.identifiers.length === 0) {
              continue;
            }
            name = generator.generateName(name);
            for (j = 0, jz = variable.identifiers.length; j < jz; ++j) {
              def = variable.identifiers[j];
              def.name = name;
            }
            for (j = 0, jz = variable.references.length; j < jz; ++j) {
              ref = variable.references[j];
              ref.identifier.name = name;
            }
          }
        }
      }
      function Label(node, upper) {
        this.node = node;
        this.upper = upper;
        this.users = [];
        this.names = new Map;
        this.name = null;
      }
      Label.prototype.mangle = function () {
        var tip, current, i, iz;
        tip = '9';
        for (current = this.upper; current; current = current.upper) {
          if (current.name !== null) {
            this.names.set(current.name, true);
          }
        }
        do {
          tip = utility.generateNextName(tip);
        } while (this.names.has(tip));
        this.name = tip;
        for (current = this.upper; current; current = current.upper) {
          current.names.set(tip, true);
        }
        this.node.label.name = tip;
        for (i = 0, iz = this.users.length; i < iz; ++i) {
          this.users[i].label.name = tip;
        }
      };
      function LabelScope(upper) {
        this.map = new Map;
        this.upper = upper;
        this.label = null;
        this.labels = [];
      }
      LabelScope.prototype.register = function register(node) {
        var name;
        assert(node.type === Syntax.LabeledStatement, 'node should be LabeledStatement');
        this.label = new Label(node, this.label);
        this.labels.push(this.label);
        name = node.label.name;
        assert(!this.map.has(name), 'duplicate label is found');
        this.map.set(name, this.label);
      };
      LabelScope.prototype.unregister = function unregister(node) {
        var name, ref;
        if (node.type !== Syntax.LabeledStatement) {
          return;
        }
        name = node.label.name;
        ref = this.map.get(name);
        this.map['delete'](name);
        this.label = ref.upper;
      };
      LabelScope.prototype.resolve = function resolve(node) {
        var name;
        if (node.label) {
          name = node.label.name;
          assert(this.map.has(name), 'unresolved label');
          this.map.get(name).users.push(node);
        }
      };
      LabelScope.prototype.close = function close() {
        var i, iz, label;
        this.labels.sort(function (lhs, rhs) {
          return rhs.users.length - lhs.users.length;
        });
        for (i = 0, iz = this.labels.length; i < iz; ++i) {
          label = this.labels[i];
          label.mangle();
        }
        return this.upper;
      };
      function mangleLabels(tree) {
        var labelScope;
        estraverse.traverse(tree, {
          enter: function (node) {
            if (escope.Scope.isVariableScopeRequired(node)) {
              labelScope = new LabelScope(labelScope);
              return;
            }
            switch (node.type) {
            case Syntax.LabeledStatement:
              labelScope.register(node);
              break;
            case Syntax.BreakStatement:
            case Syntax.ContinueStatement:
              labelScope.resolve(node);
              break;
            }
          },
          leave: function (node) {
            labelScope.unregister(node);
            if (escope.Scope.isVariableScopeRequired(node)) {
              labelScope = labelScope.close();
            }
          }
        });
        return tree;
      }
      function mangle(tree, options) {
        var result, manager, i, iz;
        if (options == null) {
          options = { destructive: true };
        }
        result = options.destructive == null || options.destructive ? tree : utility.deepCopy(tree);
        manager = escope.analyze(result, { directive: true });
        for (i = 0, iz = manager.scopes.length; i < iz; ++i) {
          run(manager.scopes[i], options);
        }
        return mangleLabels(result);
      }
      exports.mangle = mangle;
      exports.version = version;
      exports.generateNextName = utility.generateNextName;
    }());
  });
  require.define('/esshorten/package.json', function (module, exports, __dirname, __filename) {
    module.exports = {
      '_from': 'esshorten@~1.1.0',
      '_id': 'esshorten@1.1.1',
      '_inBundle': false,
      '_integrity': 'sha1-F0+Wt8wmfkaHLYFOfbfCkL3/Yak=',
      '_location': '/esshorten',
      '_phantomChildren': {},
      '_requested': {
        'type': 'range',
        'registry': true,
        'raw': 'esshorten@~1.1.0',
        'name': 'esshorten',
        'escapedName': 'esshorten',
        'rawSpec': '~1.1.0',
        'saveSpec': null,
        'fetchSpec': '~1.1.0'
      },
      '_requiredBy': ['/esmangle'],
      '_resolved': 'https://registry.npm.taobao.org/esshorten/download/esshorten-1.1.1.tgz',
      '_shasum': '174f96b7cc267e46872d814e7db7c290bdff61a9',
      '_spec': 'esshorten@~1.1.0',
      '_where': 'D:\\work\\efront\\node_modules\\esmangle',
      'bugs': { 'url': 'https://github.com/estools/esshorten/issues' },
      'bundleDependencies': false,
      'dependencies': {
        'escope': '~1.0.1',
        'estraverse': '~4.1.1',
        'esutils': '~2.0.2'
      },
      'deprecated': false,
      'description': 'Shorten (mangle) names in JavaScript code',
      'devDependencies': {
        'chai': '*',
        'coffee-script': '~1.10.0',
        'commonjs-everywhere': '~0.9.7',
        'gulp': '~3.9.0',
        'gulp-jshint': '~1.11.2',
        'gulp-mocha': '~2.1.3',
        'jshint-stylish': '~2.0.1'
      },
      'directories': { 'lib': './lib' },
      'engines': { 'node': '>=0.6.0' },
      'homepage': 'https://github.com/estools/esshorten#readme',
      'licenses': [{
          'type': 'BSD',
          'url': 'http://github.com/estools/esshorten/raw/master/LICENSE.BSD'
        }],
      'main': 'lib/esshorten.js',
      'maintainers': [{
          'name': 'Yusuke Suzuki',
          'email': 'utatane.tea@gmail.com',
          'url': 'http://github.com/Constellation'
        }],
      'name': 'esshorten',
      'repository': {
        'type': 'git',
        'url': 'git+ssh://git@github.com/estools/esshorten.git'
      },
      'scripts': {
        'lint': 'gulp lint',
        'test': 'gulp travis',
        'unit-test': 'gulp test'
      },
      'version': '1.1.1'
    };
  });
  require.define('/esshorten/lib/map.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Map;
      if (typeof global.Map !== 'undefined') {
        Map = global.Map;
      } else {
        Map = function Map() {
          this.__data = {};
        };
        Map.prototype.get = function MapGet(key) {
          key = '$' + key;
          if (this.__data.hasOwnProperty(key)) {
            return this.__data[key];
          }
        };
        Map.prototype.has = function MapHas(key) {
          key = '$' + key;
          return this.__data.hasOwnProperty(key);
        };
        Map.prototype.set = function MapSet(key, val) {
          key = '$' + key;
          this.__data[key] = val;
        };
        Map.prototype['delete'] = function MapDelete(key) {
          key = '$' + key;
          return delete this.__data[key];
        };
        Map.prototype.clear = function MapClear() {
          this.__data = {};
        };
        Map.prototype.forEach = function MapForEach(callback, thisArg) {
          var real, key;
          for (real in this.__data) {
            if (this.__data.hasOwnProperty(real)) {
              key = real.substring(1);
              callback.call(thisArg, this.__data[real], key, this);
            }
          }
        };
        Map.prototype.keys = function MapKeys() {
          var real, result;
          result = [];
          for (real in this.__data) {
            if (this.__data.hasOwnProperty(real)) {
              result.push(real.substring(1));
            }
          }
          return result;
        };
        Map.prototype.values = function MapValues() {
          var real, result;
          result = [];
          for (real in this.__data) {
            if (this.__data.hasOwnProperty(real)) {
              result.push(this.__data[real]);
            }
          }
          return result;
        };
        Map.prototype.items = function MapItems() {
          var real, result;
          result = [];
          for (real in this.__data) {
            if (this.__data.hasOwnProperty(real)) {
              result.push([
                real.substring(1),
                this.__data[real]
              ]);
            }
          }
          return result;
        };
      }
      module.exports = Map;
    }());
  });
  require.define('/esshorten/lib/utility.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var isArray, NameSequence, ZeroSequenceCache;
      isArray = Array.isArray;
      if (!isArray) {
        isArray = function isArray(array) {
          return Object.prototype.toString.call(array) === '[object Array]';
        };
      }
      function deepCopy(obj) {
        function deepCopyInternal(obj, result) {
          var key, val;
          for (key in obj) {
            if (key.lastIndexOf('__', 0) === 0) {
              continue;
            }
            if (obj.hasOwnProperty(key)) {
              val = obj[key];
              if (typeof val === 'object' && val !== null) {
                if (val instanceof RegExp) {
                  val = new RegExp(val);
                } else {
                  val = deepCopyInternal(val, isArray(val) ? [] : {});
                }
              }
              result[key] = val;
            }
          }
          return result;
        }
        return deepCopyInternal(obj, isArray(obj) ? [] : {});
      }
      function stringRepeat(str, num) {
        var result = '';
        for (num |= 0; num > 0; num >>>= 1, str += str) {
          if (num & 1) {
            result += str;
          }
        }
        return result;
      }
      ZeroSequenceCache = [];
      function zeroSequence(num) {
        var res = ZeroSequenceCache[num];
        if (res !== undefined) {
          return res;
        }
        res = stringRepeat('0', num);
        ZeroSequenceCache[num] = res;
        return res;
      }
      NameSequence = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$'.split('');
      function generateNextName(name) {
        var ch, index, cur;
        cur = name.length - 1;
        do {
          ch = name.charAt(cur);
          index = NameSequence.indexOf(ch);
          if (index !== NameSequence.length - 1) {
            return name.substring(0, cur) + NameSequence[index + 1] + zeroSequence(name.length - (cur + 1));
          }
          --cur;
        } while (cur >= 0);
        return 'a' + zeroSequence(name.length);
      }
      exports.generateNextName = generateNextName;
      exports.deepCopy = deepCopy;
    }());
  });
  require.define('/esshorten/node_modules/esutils/lib/utils.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      exports.ast = require('/esshorten/node_modules/esutils/lib/ast.js', module);
      exports.code = require('/esshorten/node_modules/esutils/lib/code.js', module);
      exports.keyword = require('/esshorten/node_modules/esutils/lib/keyword.js', module);
    }());
  });
  require.define('/esshorten/node_modules/esutils/lib/keyword.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var code = require('/esshorten/node_modules/esutils/lib/code.js', module);
      function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
          return true;
        default:
          return false;
        }
      }
      function isKeywordES5(id, strict) {
        if (!strict && id === 'yield') {
          return false;
        }
        return isKeywordES6(id, strict);
      }
      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }
        switch (id.length) {
        case 2:
          return id === 'if' || id === 'in' || id === 'do';
        case 3:
          return id === 'var' || id === 'for' || id === 'new' || id === 'try';
        case 4:
          return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
        case 5:
          return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
        case 6:
          return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
        case 7:
          return id === 'default' || id === 'finally' || id === 'extends';
        case 8:
          return id === 'function' || id === 'continue' || id === 'debugger';
        case 10:
          return id === 'instanceof';
        default:
          return false;
        }
      }
      function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
      }
      function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
      }
      function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
      }
      function isIdentifierNameES5(id) {
        var i, iz, ch;
        if (id.length === 0) {
          return false;
        }
        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
          return false;
        }
        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (!code.isIdentifierPartES5(ch)) {
            return false;
          }
        }
        return true;
      }
      function decodeUtf16(lead, trail) {
        return (lead - 55296) * 1024 + (trail - 56320) + 65536;
      }
      function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;
        if (id.length === 0) {
          return false;
        }
        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (55296 <= ch && ch <= 56319) {
            ++i;
            if (i >= iz) {
              return false;
            }
            lowCh = id.charCodeAt(i);
            if (!(56320 <= lowCh && lowCh <= 57343)) {
              return false;
            }
            ch = decodeUtf16(ch, lowCh);
          }
          if (!check(ch)) {
            return false;
          }
          check = code.isIdentifierPartES6;
        }
        return true;
      }
      function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
      }
      function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
      }
      module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
      };
    }());
  });
  require.define('/esshorten/node_modules/esutils/lib/code.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
      ES5Regex = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      };
      ES6Regex = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };
      function isDecimalDigit(ch) {
        return 48 <= ch && ch <= 57;
      }
      function isHexDigit(ch) {
        return 48 <= ch && ch <= 57 || 97 <= ch && ch <= 102 || 65 <= ch && ch <= 70;
      }
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      NON_ASCII_WHITESPACES = [
        5760,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8199,
        8200,
        8201,
        8202,
        8239,
        8287,
        12288,
        65279
      ];
      function isWhiteSpace(ch) {
        return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
      }
      function isLineTerminator(ch) {
        return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
      }
      function fromCodePoint(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        }
        var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
        var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
        return cu1 + cu2;
      }
      IDENTIFIER_START = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch === 36 || ch === 95;
      }
      IDENTIFIER_PART = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95;
      }
      function isIdentifierStartES5(ch) {
        return ch < 128 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
      }
      function isIdentifierPartES5(ch) {
        return ch < 128 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
      }
      function isIdentifierStartES6(ch) {
        return ch < 128 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
      }
      function isIdentifierPartES6(ch) {
        return ch < 128 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
      }
      module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
      };
    }());
  });
  require.define('/esshorten/node_modules/esutils/lib/ast.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      function isExpression(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
        case 'ArrayExpression':
        case 'AssignmentExpression':
        case 'BinaryExpression':
        case 'CallExpression':
        case 'ConditionalExpression':
        case 'FunctionExpression':
        case 'Identifier':
        case 'Literal':
        case 'LogicalExpression':
        case 'MemberExpression':
        case 'NewExpression':
        case 'ObjectExpression':
        case 'SequenceExpression':
        case 'ThisExpression':
        case 'UnaryExpression':
        case 'UpdateExpression':
          return true;
        }
        return false;
      }
      function isIterationStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
        case 'DoWhileStatement':
        case 'ForInStatement':
        case 'ForStatement':
        case 'WhileStatement':
          return true;
        }
        return false;
      }
      function isStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
        case 'BlockStatement':
        case 'BreakStatement':
        case 'ContinueStatement':
        case 'DebuggerStatement':
        case 'DoWhileStatement':
        case 'EmptyStatement':
        case 'ExpressionStatement':
        case 'ForInStatement':
        case 'ForStatement':
        case 'IfStatement':
        case 'LabeledStatement':
        case 'ReturnStatement':
        case 'SwitchStatement':
        case 'ThrowStatement':
        case 'TryStatement':
        case 'VariableDeclaration':
        case 'WhileStatement':
        case 'WithStatement':
          return true;
        }
        return false;
      }
      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
      }
      function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
          if (node.alternate != null) {
            return node.alternate;
          }
          return node.consequent;
        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
          return node.body;
        }
        return null;
      }
      function isProblematicIfStatement(node) {
        var current;
        if (node.type !== 'IfStatement') {
          return false;
        }
        if (node.alternate == null) {
          return false;
        }
        current = node.consequent;
        do {
          if (current.type === 'IfStatement') {
            if (current.alternate == null) {
              return true;
            }
          }
          current = trailingStatement(current);
        } while (current);
        return false;
      }
      module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,
        trailingStatement: trailingStatement
      };
    }());
  });
  require.define('/esshorten/node_modules/estraverse/estraverse.js', function (module, exports, __dirname, __filename) {
    (function clone(exports) {
      'use strict';
      var Syntax, isArray, VisitorOption, VisitorKeys, objectCreate, objectKeys, BREAK, SKIP, REMOVE;
      function ignoreJSHintError() {
      }
      isArray = Array.isArray;
      if (!isArray) {
        isArray = function isArray(array) {
          return Object.prototype.toString.call(array) === '[object Array]';
        };
      }
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === 'object' && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
      ignoreJSHintError(shallowCopy);
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      function lowerBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            i = current + 1;
            len -= diff + 1;
          } else {
            len = diff;
          }
        }
        return i;
      }
      ignoreJSHintError(lowerBound);
      objectCreate = Object.create || function () {
        function F() {
        }
        return function (o) {
          F.prototype = o;
          return new F;
        };
      }();
      objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
          keys.push(key);
        }
        return keys;
      };
      function extend(to, from) {
        var keys = objectKeys(from), key, i, len;
        for (i = 0, len = keys.length; i < len; i += 1) {
          key = keys[i];
          to[key] = from[key];
        }
        return to;
      }
      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
      };
      VisitorKeys = {
        AssignmentExpression: [
          'left',
          'right'
        ],
        AssignmentPattern: [
          'left',
          'right'
        ],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: [
          'params',
          'body'
        ],
        AwaitExpression: ['argument'],
        BlockStatement: ['body'],
        BinaryExpression: [
          'left',
          'right'
        ],
        BreakStatement: ['label'],
        CallExpression: [
          'callee',
          'arguments'
        ],
        CatchClause: [
          'param',
          'body'
        ],
        ClassBody: ['body'],
        ClassDeclaration: [
          'id',
          'superClass',
          'body'
        ],
        ClassExpression: [
          'id',
          'superClass',
          'body'
        ],
        ComprehensionBlock: [
          'left',
          'right'
        ],
        ComprehensionExpression: [
          'blocks',
          'filter',
          'body'
        ],
        ConditionalExpression: [
          'test',
          'consequent',
          'alternate'
        ],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: [
          'body',
          'test'
        ],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: [
          'declaration',
          'specifiers',
          'source'
        ],
        ExportSpecifier: [
          'exported',
          'local'
        ],
        ExpressionStatement: ['expression'],
        ForStatement: [
          'init',
          'test',
          'update',
          'body'
        ],
        ForInStatement: [
          'left',
          'right',
          'body'
        ],
        ForOfStatement: [
          'left',
          'right',
          'body'
        ],
        FunctionDeclaration: [
          'id',
          'params',
          'body'
        ],
        FunctionExpression: [
          'id',
          'params',
          'body'
        ],
        GeneratorExpression: [
          'blocks',
          'filter',
          'body'
        ],
        Identifier: [],
        IfStatement: [
          'test',
          'consequent',
          'alternate'
        ],
        ImportDeclaration: [
          'specifiers',
          'source'
        ],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: [
          'imported',
          'local'
        ],
        Literal: [],
        LabeledStatement: [
          'label',
          'body'
        ],
        LogicalExpression: [
          'left',
          'right'
        ],
        MemberExpression: [
          'object',
          'property'
        ],
        MetaProperty: [
          'meta',
          'property'
        ],
        MethodDefinition: [
          'key',
          'value'
        ],
        ModuleSpecifier: [],
        NewExpression: [
          'callee',
          'arguments'
        ],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: [
          'key',
          'value'
        ],
        RestElement: ['argument'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: [
          'discriminant',
          'cases'
        ],
        SwitchCase: [
          'test',
          'consequent'
        ],
        TaggedTemplateExpression: [
          'tag',
          'quasi'
        ],
        TemplateElement: [],
        TemplateLiteral: [
          'quasis',
          'expressions'
        ],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: [
          'block',
          'handler',
          'finalizer'
        ],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: [
          'id',
          'init'
        ],
        WhileStatement: [
          'test',
          'body'
        ],
        WithStatement: [
          'object',
          'body'
        ],
        YieldExpression: ['argument']
      };
      BREAK = {};
      SKIP = {};
      REMOVE = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
      };
      Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;
        function addToPath(result, path) {
          if (isArray(path)) {
            for (j = 0, jz = path.length; j < jz; ++j) {
              result.push(path[j]);
            }
          } else {
            result.push(path);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = undefined;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function () {
        this.notify(SKIP);
      };
      Controller.prototype['break'] = function () {
        this.notify(BREAK);
      };
      Controller.prototype.remove = function () {
        this.notify(REMOVE);
      };
      Controller.prototype.__initialize = function (root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = visitor.fallback === 'iteration';
        this.__keys = VisitorKeys;
        if (visitor.keys) {
          this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
      };
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
      }
      Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = objectKeys(node);
              } else {
                throw new Error('Unknown node type ' + nodeType + '.');
              }
            }
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                  if (!candidate[current2]) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current])) {
                    element = new Element(candidate[current2], [
                      key,
                      current2
                    ], 'Property', null);
                  } else if (isNode(candidate[current2])) {
                    element = new Element(candidate[current2], [
                      key,
                      current2
                    ], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                worklist.push(new Element(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace(root, visitor) {
        function removeElem(element) {
          var i, key, nextElem, parent;
          if (element.ref.remove()) {
            key = element.ref.key;
            parent = element.ref.parent;
            i = worklist.length;
            while (i--) {
              nextElem = worklist[i];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = { root: root };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
              element.ref.replace(target);
            }
            if (this.__state === REMOVE || target === REMOVE) {
              removeElem(element);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = objectKeys(node);
            } else {
              throw new Error('Unknown node type ' + nodeType + '.');
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], 'Property', new Reference(candidate, current2));
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], null, new Reference(candidate, current2));
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller;
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller;
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [
          comment.range[0],
          comment.range[1]
        ];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error('attachComments needs range information');
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [
                0,
                tree.range[0]
              ];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (comment.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (node.range[1] < comment.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports.version = require('/esshorten/node_modules/estraverse/package.json', module).version;
      exports.Syntax = Syntax;
      exports.traverse = traverse;
      exports.replace = replace;
      exports.attachComments = attachComments;
      exports.VisitorKeys = VisitorKeys;
      exports.VisitorOption = VisitorOption;
      exports.Controller = Controller;
      exports.cloneEnvironment = function () {
        return clone({});
      };
      return exports;
    }(exports));
  });
  require.define('/esshorten/node_modules/estraverse/package.json', function (module, exports, __dirname, __filename) {
    module.exports = {
      '_from': 'estraverse@~4.1.1',
      '_id': 'estraverse@4.1.1',
      '_inBundle': false,
      '_integrity': 'sha1-9srKcokzqFDvkGYdDheYK6RxEaI=',
      '_location': '/esshorten/estraverse',
      '_phantomChildren': {},
      '_requested': {
        'type': 'range',
        'registry': true,
        'raw': 'estraverse@~4.1.1',
        'name': 'estraverse',
        'escapedName': 'estraverse',
        'rawSpec': '~4.1.1',
        'saveSpec': null,
        'fetchSpec': '~4.1.1'
      },
      '_requiredBy': ['/esshorten'],
      '_resolved': 'https://registry.npm.taobao.org/estraverse/download/estraverse-4.1.1.tgz?cache=0&sync_timestamp=1596642998635&other_urls=https%3A%2F%2Fregistry.npm.taobao.org%2Festraverse%2Fdownload%2Festraverse-4.1.1.tgz',
      '_shasum': 'f6caca728933a850ef90661d0e17982ba47111a2',
      '_spec': 'estraverse@~4.1.1',
      '_where': 'D:\\work\\efront\\node_modules\\esshorten',
      'bugs': { 'url': 'https://github.com/estools/estraverse/issues' },
      'bundleDependencies': false,
      'deprecated': false,
      'description': 'ECMAScript JS AST traversal functions',
      'devDependencies': {
        'chai': '^2.1.1',
        'coffee-script': '^1.8.0',
        'espree': '^1.11.0',
        'gulp': '^3.8.10',
        'gulp-bump': '^0.2.2',
        'gulp-filter': '^2.0.0',
        'gulp-git': '^1.0.1',
        'gulp-tag-version': '^1.2.1',
        'jshint': '^2.5.6',
        'mocha': '^2.1.0'
      },
      'engines': { 'node': '>=0.10.0' },
      'homepage': 'https://github.com/estools/estraverse',
      'license': 'BSD-2-Clause',
      'main': 'estraverse.js',
      'maintainers': [{
          'name': 'Yusuke Suzuki',
          'email': 'utatane.tea@gmail.com',
          'url': 'http://github.com/Constellation'
        }],
      'name': 'estraverse',
      'repository': {
        'type': 'git',
        'url': 'git+ssh://git@github.com/estools/estraverse.git'
      },
      'scripts': {
        'lint': 'jshint estraverse.js',
        'test': 'npm run-script lint && npm run-script unit-test',
        'unit-test': 'mocha --compilers coffee:coffee-script/register'
      },
      'version': '4.1.1'
    };
  });
  global.esmangle = require('/esmangle/lib/esmangle.js');
}.call(this, this));module.exports = this.esmangle;
